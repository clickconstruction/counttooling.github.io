<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ClickCount — PDF Takeoff Tool</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=DM+Sans:wght@300;400;500;600&family=Instrument+Serif:ital@0;1&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    :root {
      --bg: #0f0f11;
      --surface: #17171a;
      --surface2: #1e1e22;
      --surface3: #26262c;
      --border: #2e2e36;
      --border2: #3a3a44;
      --accent: #e8c547;
      --accent2: #c9a82e;
      --text: #f0ede8;
      --text2: #9e9b96;
      --text3: #5e5c58;
      --red: #e85447;
      --blue: #4a9eff;
      --green: #47c88e;
      --purple: #a47fff;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'DM Sans', sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; overflow: hidden; }
    .app { display: flex; flex-direction: column; height: 100vh; }
    .header { height: 52px; display: flex; align-items: center; gap: 8px; padding: 0 12px; background: var(--surface); border-bottom: 1px solid var(--border); flex-shrink: 0; }
    .header .logo { font-family: 'Instrument Serif', serif; font-size: 1.4rem; color: var(--accent); margin-right: 8px; }
    .header .divider { width: 1px; height: 24px; background: var(--border); }
    .header button { min-height: 44px; min-width: 44px; padding: 6px 12px; background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; color: var(--text); cursor: pointer; font-family: inherit; font-size: 0.9rem; }
    .header button:hover { background: var(--surface3); }
    .header button.active { background: var(--accent); color: var(--bg); border-color: var(--accent); }
    .header button.danger { color: var(--red); border-color: var(--red); }
    .header button.danger:hover { background: rgba(232,84,71,0.2); }
    .header .spacer { flex: 1; }
    .header #setScale.scale-set { display: flex; flex-direction: column; align-items: center; line-height: 1.2; padding: 6px 10px; }
    .header #setScale.scale-set .scale-value { font-size: 0.75rem; font-family: 'DM Mono', monospace; }
    .header .hamburger { display: none; }
    @media (max-width: 768px) {
      .header .hamburger { display: flex; }
      .header .sidebar-triggers { display: none; }
    }
    .main { display: flex; flex: 1; overflow: hidden; }
    .sidebar { width: 220px; background: var(--surface); border-right: 1px solid var(--border); overflow-y: auto; flex-shrink: 0; transition: transform 0.2s; }
    @media (max-width: 768px) {
      .sidebar { position: fixed; left: 0; top: 52px; bottom: 0; z-index: 100; transform: translateX(-100%); }
      body.sidebar-open .sidebar { transform: translateX(0); }
      .sidebar-backdrop { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 99; }
      body.sidebar-open .sidebar-backdrop { display: block; }
    }
    .sidebar-section { padding: 12px; border-bottom: 1px solid var(--border); }
    .sidebar-section h3 { font-size: 0.75rem; text-transform: uppercase; color: var(--text3); margin-bottom: 8px; }
    .sidebar-section h3.section-settings { cursor: pointer; padding: 2px 0; }
    .sidebar-section h3.section-settings:hover { color: var(--text2); }
    #pagesSection.collapsed #pagesList { display: none; }
    .collapse-icon { font-size: 0.65rem; margin-left: 4px; opacity: 0.7; }
    .modal-card input[type="range"] { width: 100%; padding: 0; height: 24px; }
    .sidebar-item { display: flex; align-items: center; gap: 8px; padding: 6px 0; cursor: pointer; min-height: 44px; }
    .sidebar-item.active { background: var(--surface2); border-radius: 6px; margin: 2px -4px; padding: 4px 12px 4px 8px; border-left: 3px solid var(--accent); }
    .sidebar-item .swatch { width: 16px; height: 16px; border-radius: 4px; flex-shrink: 0; }
    .sidebar-item .icon-svg { width: 20px; height: 20px; flex-shrink: 0; }
    .sidebar-item .name { flex: 1; overflow: hidden; text-overflow: ellipsis; }
    .sidebar-item .badge { background: var(--surface3); padding: 2px 6px; border-radius: 4px; font-size: 0.8rem; font-family: 'DM Mono', monospace; }
    .sidebar-item .badge.badge-scale-set { background: var(--accent); color: #000; }
    .sidebar-item .edit-btn { padding: 4px; cursor: pointer; opacity: 0.7; }
    .sidebar-item .edit-btn:hover { opacity: 1; }
    .sidebar-item-line-type { flex-direction: column; align-items: stretch; gap: 4px; }
    .sidebar-item-line-type .line-type-name { font-weight: 500; }
    .sidebar-item-line-type .line-type-row { display: flex; align-items: center; gap: 8px; }
    .sidebar-btn { width: 100%; padding: 10px 16px; margin-bottom: 8px; background: transparent; border: 1px solid var(--border); border-radius: 8px; color: var(--text2); font-family: inherit; font-size: 0.9rem; font-weight: 500; cursor: pointer; transition: all 0.15s ease; }
    .sidebar-btn:hover { background: var(--surface2); color: var(--text); border-color: var(--border2); }
    .sidebar-btn.sidebar-btn-primary { background: var(--accent); color: var(--bg); border-color: var(--accent); }
    .sidebar-btn.sidebar-btn-primary:hover { background: var(--accent2); border-color: var(--accent2); }
    .canvas-area { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }
    .canvas-wrapper { flex: 1; overflow: hidden; position: relative; }
    .canvas-container { position: absolute; transform-origin: 0 0; }
    .canvas-container canvas { display: block; position: absolute; left: 0; top: 0; }
    .canvas-container .pdf-canvas { z-index: 0; }
    .canvas-container .ann-canvas { z-index: 1; pointer-events: none; }
    .canvas-container .ann-canvas.interactive { pointer-events: auto; }
    .zoom-bar { display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--surface); border-top: 1px solid var(--border); }
    .zoom-bar button { width: 32px; height: 32px; border: 1px solid var(--border); background: var(--surface2); color: var(--text); border-radius: 4px; cursor: pointer; font-size: 1rem; }
    .zoom-bar .zoom-pct { font-family: 'DM Mono', monospace; min-width: 48px; text-align: center; font-size: 0.85rem; }
    .page-nav { display: flex; align-items: center; gap: 8px; padding: 8px; }
    .page-nav button { padding: 6px 12px; border: 1px solid var(--border); background: var(--surface2); color: var(--text); border-radius: 4px; cursor: pointer; }
    .polyline-finish-bar { display: none; padding: 8px; background: var(--surface2); border-top: 1px solid var(--border); gap: 8px; }
    .polyline-finish-bar.visible { display: flex; }
    .status-bar { padding: 4px 12px; font-size: 0.8rem; color: var(--text2); background: var(--surface); border-top: 1px solid var(--border); display: flex; align-items: center; gap: 12px; }
    .status-bar .dot { width: 6px; height: 6px; border-radius: 50%; background: var(--green); }
    .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 200; align-items: center; justify-content: center; }
    .modal-overlay.visible { display: flex; }
    .modal-card { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 24px; max-width: 400px; width: 90%; }
    .modal-card h2 { margin-bottom: 16px; font-size: 1.1rem; }
    .modal-card .form-group { margin-bottom: 16px; }
    .modal-card .form-group-center { text-align: center; }
    .modal-card label { display: block; margin-bottom: 4px; font-size: 0.85rem; color: var(--text2); }
    .modal-card input, .modal-card select { width: 100%; padding: 8px 12px; background: var(--surface2); border: 1px solid var(--border); border-radius: 4px; color: var(--text); font-size: 1rem; }
    .modal-card .color-row { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .modal-card .color-swatch { width: 28px; height: 28px; border-radius: 6px; cursor: pointer; border: 2px solid transparent; }
    .modal-card .color-swatch.selected { border-color: var(--accent); }
    .modal-card .icon-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; max-height: 200px; overflow-y: auto; margin-top: 8px; }
    .modal-card .icon-cell { width: 36px; height: 36px; padding: 4px; cursor: pointer; border-radius: 4px; display: flex; align-items: center; justify-content: center; border: 2px solid transparent; }
    .modal-card .icon-cell:hover { background: var(--surface3); }
    .modal-card .icon-cell.selected { background: var(--surface3); border-color: var(--accent); }
    .modal-card .icon-cell svg { width: 24px; height: 24px; }
    .modal-card .actions { display: flex; gap: 12px; justify-content: flex-end; margin-top: 24px; }
    .modal-card .actions button { padding: 10px 20px; border-radius: 8px; font-size: 0.9rem; font-weight: 500; cursor: pointer; transition: all 0.15s ease; border: none; font-family: inherit; min-height: 44px; }
    .modal-card .actions button:first-child { background: transparent; color: var(--text2); border: 1px solid var(--border); }
    .modal-card .actions button:first-child:hover { background: var(--surface2); color: var(--text); border-color: var(--border2); }
    .modal-card .actions button:last-child { background: var(--accent); color: var(--bg); }
    .modal-card .actions button:last-child:hover { background: var(--accent2); }
    .modal-card .actions button.danger { background: var(--red); color: #fff; }
    .modal-card .actions button.danger:hover { background: rgba(232,84,71,0.9); }
    .modal-card.modal-card-toast { width: fit-content; max-width: none; }
    .context-menu { position: fixed; background: var(--surface); border: 1px solid var(--border); border-radius: 6px; padding: 4px; z-index: 300; min-width: 120px; }
    .context-menu button { display: block; width: 100%; padding: 8px 12px; text-align: left; background: none; border: none; color: var(--text); cursor: pointer; font-family: inherit; font-size: 0.9rem; }
    .context-menu button:hover { background: var(--surface2); }
    .context-menu button.danger { color: var(--red); }
    .context-menu { display: none; }
    .context-menu.visible { display: block; }
    input[type="file"] { display: none; }
  </style>
</head>
<body>
  <div class="app">
    <header class="header">
      <button class="hamburger" id="hamburger" aria-label="Menu">☰</button>
      <span class="logo">ClickCount</span>
      <span class="divider"></span>
      <button id="uploadPdf">Upload PDF</button>
      <input type="file" id="pdfInput" accept=".pdf" multiple>
      <span class="divider"></span>
      <button id="setScale">Set Scale</button>
      <span class="divider sidebar-triggers"></span>
      <button id="moveBtn" class="sidebar-triggers">Move</button>
      <button id="counterBtn" class="sidebar-triggers">Counter</button>
      <button id="quickLine" class="sidebar-triggers">Quick Line</button>
      <button id="polylineBtn" class="sidebar-triggers">Polyline</button>
      <button id="doneEditing" class="sidebar-triggers" style="display:none;">Done Editing</button>
      <span class="spacer"></span>
      <button id="exportBtn">Export</button>
      <button id="importBtn">Import</button>
      <input type="file" id="importInput" accept=".json">
      <button id="clearPage" class="danger">Clear Page</button>
    </header>
    <div class="main">
      <div class="sidebar-backdrop" id="sidebarBackdrop"></div>
      <aside class="sidebar">
        <div class="sidebar-section" id="pagesSection">
          <h3 id="pagesSectionTitle" class="section-settings" title="Click to collapse">Pages <span class="collapse-icon" id="pagesCollapseIcon">▼</span></h3>
          <div id="pagesList"></div>
        </div>
        <div class="sidebar-section">
          <h3 id="countersSectionTitle" class="section-settings" title="Counter settings">Counters</h3>
          <button id="addCounter" class="sidebar-btn">+ Add Counter</button>
          <div id="countersList"></div>
        </div>
        <div class="sidebar-section">
          <h3 id="lineTypesSectionTitle" class="section-settings" title="Line type settings">Line Types</h3>
          <button id="addLineType" class="sidebar-btn">+ Add Line Type</button>
          <div id="lineTypesList"></div>
        </div>
        <div class="sidebar-section">
          <h3>Lines</h3>
          <div id="linesList"></div>
        </div>
        <div class="sidebar-section">
          <h3>Summary</h3>
          <div id="summaryList"></div>
        </div>
        <div class="sidebar-section">
          <button id="printReport" class="sidebar-btn sidebar-btn-primary">Print Report</button>
          <button id="exportPdf" class="sidebar-btn">Export PDF</button>
        </div>
      </aside>
      <div class="canvas-area">
        <div class="canvas-wrapper" id="canvasWrapper">
          <div class="canvas-container" id="canvasContainer">
            <canvas id="pdfCanvas" class="pdf-canvas"></canvas>
            <canvas id="annCanvas" class="ann-canvas"></canvas>
          </div>
        </div>
        <div class="zoom-bar">
          <button id="zoomOut">−</button>
          <span class="zoom-pct" id="zoomPct">100%</span>
          <button id="zoomIn">+</button>
          <button id="zoomFit" title="Fit">⊡</button>
        </div>
        <div class="page-nav">
          <button id="prevPage">‹</button>
          <span id="pageInfo">Page 0 of 0</span>
          <button id="nextPage">›</button>
        </div>
        <div class="polyline-finish-bar" id="polylineFinishBar">
          <button id="finishPolyline">Finish</button>
          <button id="closePolygon">Close Polygon</button>
        </div>
        <div class="status-bar">
          <span class="dot"></span>
          <span id="statusMode">Ready</span>
          <span id="statusCoords">—</span>
        </div>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="scaleModal">
    <div class="modal-card">
      <h2>Set Scale</h2>
      <p id="scaleInfo" class="form-group">You selected a line spanning 0 pdf-pts.</p>
      <div class="form-group">
        <label>Real-world length</label>
        <input type="number" id="scaleValue" step="0.01" min="0.01" placeholder="e.g. 10">
      </div>
      <div class="form-group">
        <label>Unit</label>
        <select id="scaleUnit">
          <option value="ft">ft</option>
          <option value="in">in</option>
          <option value="m">m</option>
          <option value="cm">cm</option>
          <option value="yd">yd</option>
        </select>
      </div>
      <div class="actions">
        <button id="scaleCancel">Cancel</button>
        <button id="scaleSet">Set Scale</button>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="counterModal">
    <div class="modal-card">
      <h2>Create Counter</h2>
      <div class="form-group">
        <label>Name</label>
        <input type="text" id="counterName" placeholder="e.g. Water Closet">
      </div>
      <div class="form-group">
        <label>Search icon</label>
        <input type="text" id="counterIconSearch" placeholder="Search...">
      </div>
      <div class="form-group">
        <label>Icon</label>
        <div class="icon-grid" id="counterIconGrid"></div>
      </div>
      <div class="form-group">
        <label>Color</label>
        <div class="color-row" id="counterColorRow"></div>
      </div>
      <div class="actions">
        <button id="counterCancel">Cancel</button>
        <button id="counterCreate">Create Counter</button>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="lineTypeModal">
    <div class="modal-card">
      <h2>Create Line Type</h2>
      <div class="form-group">
        <label>Name</label>
        <input type="text" id="lineTypeName" placeholder="e.g. Pipe">
      </div>
      <div class="form-group">
        <label>Color</label>
        <div class="color-row" id="lineTypeColorRow"></div>
      </div>
      <div class="actions">
        <button id="lineTypeCancel">Cancel</button>
        <button id="lineTypeCreate">Create Line Type</button>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="polylineModal">
    <div class="modal-card">
      <h2>New Polyline</h2>
      <div class="form-group">
        <label>Line Type</label>
        <select id="polylineLineType"></select>
        <a href="#" id="polylineNewLineType" style="font-size:0.85rem;color:var(--accent);">Create new line type</a>
      </div>
      <div class="form-group">
        <label>Name</label>
        <input type="text" id="polylineName" placeholder="e.g. Main run">
      </div>
      <div class="form-group">
        <label>Color</label>
        <div class="color-row" id="polylineColorRow"></div>
      </div>
      <div class="actions">
        <button id="polylineCancel">Cancel</button>
        <button id="polylineStart">Start Drawing</button>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="counterSettingsModal">
    <div class="modal-card">
      <h2>Counter Settings</h2>
      <div class="form-group">
        <label>Icon size: <span id="counterSizeVal">20</span>px</label>
        <input type="range" id="counterSize" min="12" max="96" value="20" step="2">
      </div>
      <div class="form-group">
        <label>Opacity: <span id="counterOpacityVal">100</span>%</label>
        <input type="range" id="counterOpacity" min="20" max="100" value="100" step="5">
      </div>
      <div class="form-group">
        <label>Outline: <span id="counterOutlineVal">0</span>px</label>
        <input type="range" id="counterOutline" min="0" max="6" value="0" step="1">
      </div>
      <div class="form-group">
        <label>Number size: <span id="counterNumberSizeVal">10</span>px</label>
        <input type="range" id="counterNumberSize" min="8" max="32" value="10" step="1">
      </div>
      <div class="form-group form-group-center">
        <label><input type="checkbox" id="counterShowRings"> Show ring around counters</label>
      </div>
      <div class="form-group counter-ring-options">
        <label>Ring size: <span id="counterRingSizeVal">100</span>%</label>
        <input type="range" id="counterRingSize" min="50" max="200" value="100" step="5">
      </div>
      <div class="form-group counter-ring-options">
        <label>Ring opacity: <span id="counterRingOpacityVal">100</span>%</label>
        <input type="range" id="counterRingOpacity" min="20" max="100" value="100" step="5">
      </div>
      <div class="form-group form-group-center counter-ring-options">
        <label><input type="checkbox" id="counterRingSolid"> Solid ring</label>
      </div>
      <div class="actions">
        <button id="counterSettingsClose">Done</button>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="lineTypeSettingsModal">
    <div class="modal-card">
      <h2>Line Type Settings</h2>
      <div class="form-group">
        <label>Line width: <span id="lineTypeSizeVal">2</span>px</label>
        <input type="range" id="lineTypeSize" min="1" max="8" value="2" step="1">
      </div>
      <div class="form-group">
        <label>Opacity: <span id="lineTypeOpacityVal">100</span>%</label>
        <input type="range" id="lineTypeOpacity" min="20" max="100" value="100" step="5">
      </div>
      <div class="actions">
        <button id="lineTypeSettingsClose">Done</button>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="exportPdfModal">
    <div class="modal-card">
      <h2>Export PDF</h2>
      <p class="form-group" style="margin-bottom:12px;color:var(--text2);">Adjust marker and line sizes for the exported PDF:</p>
      <div class="form-group">
        <label>Marker size: <span id="exportMarkerScaleVal">75</span>%</label>
        <input type="range" id="exportMarkerScale" min="25" max="150" value="75" step="5">
      </div>
      <div class="form-group">
        <label>Line width: <span id="exportLineScaleVal">75</span>%</label>
        <input type="range" id="exportLineScale" min="25" max="150" value="75" step="5">
      </div>
      <div class="actions">
        <button id="exportPdfCancel">Cancel</button>
        <button id="exportPdfDo">Export</button>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="lineColorModal">
    <div class="modal-card">
      <h2>Choose Color</h2>
      <div class="form-group">
        <label>Choose color</label>
        <input type="color" id="lineColorCustom" style="width:100%;height:48px;cursor:pointer;">
      </div>
      <div class="form-group" id="lineColorRecentGroup">
        <label>Recent</label>
        <div class="color-row" id="lineColorRecent"></div>
      </div>
      <div class="actions">
        <button id="lineColorCancel">Cancel</button>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="setScaleFirstModal">
    <div class="modal-card modal-card-toast">
      <p style="margin:0;font-size:1rem;">Set Scale first to use Quick Line.</p>
    </div>
  </div>
  <div class="modal-overlay" id="setScaleFirstPolylineModal">
    <div class="modal-card modal-card-toast">
      <p style="margin:0;font-size:1rem;">Set Scale first to use Polyline.</p>
    </div>
  </div>
  <div class="modal-overlay" id="addLineTypeFirstModal">
    <div class="modal-card modal-card-toast">
      <p style="margin:0;font-size:1rem;">Add a line type first.</p>
    </div>
  </div>
  <div class="modal-overlay" id="selectLineTypeModal">
    <div class="modal-card">
      <h2>Select Line Type</h2>
      <p class="form-group" style="margin-bottom:12px;color:var(--text2);">Choose a line type for Quick Line:</p>
      <div id="selectLineTypeList"></div>
      <div class="actions" style="margin-top:16px;">
        <button id="selectLineTypeCancel">Cancel</button>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="clearPageConfirmModal">
    <div class="modal-card">
      <h2>Clear Page</h2>
      <p style="margin:0 0 24px 0;color:var(--text2);">Are you sure?</p>
      <div class="actions">
        <button id="clearPageCancel">Cancel</button>
        <button id="clearPageConfirm" class="danger">Clear Page</button>
      </div>
    </div>
  </div>
  <div class="context-menu" id="contextMenu">
    <button class="danger" id="ctxDelete">Delete</button>
  </div>
  <script>
  (function() {
  <!-- SECTION: Constants -->
  if (typeof pdfjsLib !== 'undefined') pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

  const TOOL = { NONE: 0, SCALE: 1, LINE: 2, POLYLINE: 3, COUNTER: 4, EDIT_POLY: 5 };
  const SCALE_MODES = { NONE: 0, POINT_A: 1, POINT_B: 2 };
  const uid = () => Math.random().toString(36).slice(2, 10);
  const COLORS = ['#e85447','#4a9eff','#e8c547','#47c88e','#a47fff','#ff7a47','#47d4d4','#ff47b0','#bfff47'];

  const WC_PATH = 'M120 64C106.7 64 96 74.7 96 88C96 101.3 106.7 112 120 112L128 112L128 260.9C126.1 262.3 124.2 263.8 122.4 265.3C106.9 278.5 96 296.9 96 319.9C96 366.8 110.3 404 133 432.4C147.2 450.1 164.1 463.7 181.5 474.2L161.6 533.9C158.3 543.7 160 554.4 166 562.7C172 571 181.7 576 192 576L448 576C458.3 576 467.9 571.1 474 562.7C480.1 554.3 481.7 543.6 478.4 533.9L458.6 474.4C476 463.9 492.9 450.3 507.1 432.6C529.8 404.2 544.1 367.1 544.1 320.1C544.1 297 533.2 278.6 517.7 265.5C515.9 264 514 262.5 512.1 261.1L512.1 112.2L520.1 112.2C533.4 112.2 544.1 101.5 544.1 88.2C544.1 74.9 533.3 64 520 64L120 64zM192 144C192 135.2 199.2 128 208 128L240 128C248.8 128 256 135.2 256 144C256 152.8 248.8 160 240 160L208 160C199.2 160 192 152.8 192 144zM320 352C231.6 352 160 337.7 160 320C160 302.3 231.6 288 320 288C408.4 288 480 302.3 480 320C480 337.7 408.4 352 320 352z';
  const WF_PATH = 'M272 32L368 32C385.7 32 400 46.3 400 64C400 81.7 385.7 96 368 96L272 96C254.3 96 240 81.7 240 64C240 46.3 254.3 32 272 32zM176 208C176 172.7 204.7 144 240 144L400 144C435.3 144 464 172.7 464 208C464 232.1 450.7 253.1 431 264C450.7 274.9 464 295.9 464 320C464 344.1 450.7 365.1 431 376C450.7 386.9 464 407.9 464 432C464 456.1 450.7 477.1 431 488C450.7 498.9 464 519.9 464 544C464 579.3 435.3 608 400 608L240 608C204.7 608 176 579.3 176 544C176 519.9 189.3 498.9 209 488C189.3 477.1 176 456.1 176 432C176 407.9 189.3 386.9 209 376C189.3 365.1 176 344.1 176 320C176 295.9 189.3 274.9 209 264C189.3 253.1 176 232.1 176 208z';
  const SINK_PATH = 'M352 160C352 142.3 366.3 128 384 128C401.7 128 416 142.3 416 160C416 177.7 430.3 192 448 192C465.7 192 480 177.7 480 160C480 107 437 64 384 64C331 64 288 107 288 160L288 352L224 352L224 312C224 281.1 198.9 256 168 256L120 256C106.7 256 96 266.7 96 280C96 293.3 106.7 304 120 304L168 304C172.4 304 176 307.6 176 312L176 352L96 352C78.3 352 64 366.3 64 384C64 401.7 78.3 416 96 416L96 480C96 533 139 576 192 576L448 576C501 576 544 533 544 480L544 416C561.7 416 576 401.7 576 384C576 366.3 561.7 352 544 352L464 352L464 312C464 307.6 467.6 304 472 304L528 304C541.3 304 552 293.3 552 280C552 266.7 541.3 256 528 256L472 256C441.1 256 416 281.1 416 312L416 352L352 352L352 160z';
  const HOSE_BIB_PATH = 'M256 128C256 110.3 270.3 96 288 96C305.7 96 320 110.3 320 128L416 128C433.7 128 448 142.3 448 160C448 177.7 433.7 192 416 192L320 192L320 256L338.7 256C347.2 256 355.3 259.4 361.3 265.4L383.9 288L415.9 288C504.3 288 575.9 359.6 575.9 448C575.9 465.7 561.6 480 543.9 480L479.9 480C462.2 480 447.9 465.7 447.9 448C447.9 430.3 433.6 416 415.9 416L379.8 416C359.6 445 325.9 464 287.9 464C249.9 464 216.2 445 196 416L96 416C78.3 416 64 401.7 64 384L64 320C64 302.3 78.3 288 96 288L192 288L214.6 265.4C220.6 259.4 228.7 256 237.2 256L255.9 256L255.9 192L159.9 192C142.2 192 127.9 177.7 127.9 160C127.9 142.3 142.3 128 160 128L256 128z';
  const SHOWER_PATH = 'M128 195.9C128 176.1 144.1 160 163.9 160C173.4 160 182.5 163.8 189.3 170.5L205.5 186.7C184.5 225.6 188.1 274.2 216.4 309.7L215 311C205.6 320.4 205.6 335.6 215 344.9C224.4 354.2 239.6 354.3 248.9 344.9L409 185C418.4 175.6 418.4 160.4 409 151.1C399.6 141.8 384.4 141.7 375.1 151.1L373.8 152.4C338.3 124.1 289.7 120.5 250.8 141.5L234.5 125.3C215.8 106.5 190.4 96 163.9 96C108.7 96 64 140.7 64 195.9L64 512C64 529.7 78.3 544 96 544C113.7 544 128 529.7 128 512L128 195.9zM320 416C337.7 416 352 401.7 352 384C352 366.3 337.7 352 320 352C302.3 352 288 366.3 288 384C288 401.7 302.3 416 320 416z';
  const BATH_PATH = 'M96 77.3c0-7.3 5.9-13.3 13.3-13.3c3.5 0 6.9 1.4 9.4 3.9l14.9 14.9C130 91.8 128 101.7 128 112c0 19.9 7.2 38 19.2 52c-5.3 9.2-4 21.1 3.8 29c9.4 9.4 24.6 9.4 33.9 0L289 89c9.4-9.4 9.4-24.6 0-33.9c-7.9-7.9-19.8-9.1-29-3.8C246 39.2 227.9 32 208 32c-10.3 0-20.2 2-29.2 5.5L163.9 22.6C149.4 8.1 129.7 0 109.3 0C66.6 0 32 34.6 32 77.3V256c-17.7 0-32 14.3-32 32s14.3 32 32 32H480c17.7 0 32-14.3 32-32s-14.3-32-32-32H96V77.3zM32 352v16c0 28.4 12.4 54 32 71.6V480c0 17.7 14.3 32 32 32s32-14.3 32-32V464H384v16c0 17.7 14.3 32 32 32s32-14.3 32-32V439.6c19.6-17.6 32-43.1 32-71.6V352H32z';
  const LAUNDRY_PATH = 'M211.8 0c7.8 0 14.3 5.7 16.7 13.2C240.8 51.9 277.1 80 320 80s79.2-28.1 91.5-66.8C413.9 5.7 420.4 0 428.2 0h12.6c22.5 0 44.2 7.9 61.5 22.3L628.5 127.4c6.6 5.5 10.7 13.5 11.4 22.1s-2.1 17.1-7.8 23.6l-56 64c-11.4 13.1-31.2 14.6-44.6 3.5L480 197.7V448c0 35.3-28.7 64-64 64H224c-35.3 0-64-28.7-64-64V197.7l-51.5 42.9c-13.3 11.1-33.1 9.6-44.6-3.5l-56-64c-5.7-6.5-8.5-15-7.8-23.6s4.8-16.6 11.4-22.1L137.7 22.3C155 7.9 176.7 0 199.2 0h12.6z';
  const WATER_HEATER_PATH = 'M159.3 5.4c7.8-7.3 19.9-7.2 27.7 .1c27.6 25.9 53.5 53.8 77.7 84c11-14.4 23.5-30.1 37-42.9c7.9-7.4 20.1-7.4 28 .1c34.6 33 63.9 76.6 84.5 118c20.3 40.8 33.8 82.5 33.8 111.9C448 404.2 348.2 512 224 512C98.4 512 0 404.1 0 276.5c0-38.4 17.8-85.3 45.4-131.7C73.3 97.7 112.7 48.6 159.3 5.4z';
  const CIRCLE_PATH = 'M528 320C528 205.1 434.9 112 320 112C205.1 112 112 205.1 112 320C112 434.9 205.1 528 320 528C434.9 528 528 434.9 528 320zM64 320C64 178.6 178.6 64 320 64C461.4 64 576 178.6 576 320C576 461.4 461.4 576 320 576C178.6 576 64 461.4 64 320z';
  const SCALE_CROSSHAIR_PATH = 'M352 128C352 110.3 337.7 96 320 96C302.3 96 288 110.3 288 128L288 288L128 288C110.3 288 96 302.3 96 320C96 337.7 110.3 352 128 352L288 352L288 512C288 529.7 302.3 544 320 544C337.7 544 352 529.7 352 512L352 352L512 352C529.7 352 544 337.7 544 320C544 302.3 529.7 288 512 288L352 288L352 128z';
  const CIRCLE_DOT_PATH = 'M320 576C178.6 576 64 461.4 64 320C64 178.6 178.6 64 320 64C461.4 64 576 178.6 576 320C576 461.4 461.4 576 320 576zM320 112C205.1 112 112 205.1 112 320C112 434.9 205.1 528 320 528C434.9 528 528 434.9 528 320C528 205.1 434.9 112 320 112zM320 416C267 416 224 373 224 320C224 267 267 224 320 224C373 224 416 267 416 320C416 373 373 416 320 416z';
  const LIGHT_PATH = 'M272 384c9.6-31.9 29.5-59.1 49.2-86.2l0 0c5.2-7.1 10.4-14.2 15.4-21.4c19.8-28.5 31.4-63 31.4-100.3C368 78.8 289.2 0 192 0S16 78.8 16 176c0 37.3 11.6 71.9 31.4 100.3c5 7.2 10.2 14.3 15.4 21.4l0 0c19.8 27.1 39.7 54.4 49.2 86.2H272zM192 512c44.2 0 80-35.8 80-80V416H112v16c0 44.2 35.8 80 80 80z';
  const PLUG_PATH = 'M96 0C78.3 0 64 14.3 64 32v96h64V32c0-17.7-14.3-32-32-32zM288 0c-17.7 0-32 14.3-32 32v96h64V32c0-17.7-14.3-32-32-32zM32 160c-17.7 0-32 14.3-32 32s14.3 32 32 32v32c0 77.4 55 142 128 156.8V480c0 17.7 14.3 32 32 32s32-14.3 32-32V412.8C297 398 352 333.4 352 256V224c17.7 0 32-14.3 32-32s-14.3-32-32-32H32z';
  const POWER_PATH = 'M349.4 44.6c5.9-13.7 1.5-29.7-10.6-38.5s-28.6-8-39.9 1.8l-256 224c-10 8.8-13.6 22.9-8.9 35.3S50.7 288 64 288H175.5L98.6 467.4c-5.9 13.7-1.5 29.7 10.6 38.5s28.6 8 39.9-1.8l256-224c10-8.8 13.6-22.9 8.9-35.3s-16.6-20.7-30-20.7H272.5L349.4 44.6z';
  const BATTERY_PATH = 'M464 160c8.8 0 16 7.2 16 16V336c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V176c0-8.8 7.2-16 16-16H464zM80 96C35.8 96 0 131.8 0 176V336c0 44.2 35.8 80 80 80H464c44.2 0 80-35.8 80-80V320c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32V176c0-44.2-35.8-80-80-80H80zm368 96H96V320H448V192z';
  const CHARGING_PATH = 'M96 0C60.7 0 32 28.7 32 64V448c-17.7 0-32 14.3-32 32s14.3 32 32 32H320c17.7 0 32-14.3 32-32s-14.3-32-32-32V304h16c22.1 0 40 17.9 40 40v32c0 39.8 32.2 72 72 72s72-32.2 72-72V252.3c32.5-10.2 56-40.5 56-76.3V144c0-8.8-7.2-16-16-16H544V80c0-8.8-7.2-16-16-16s-16 7.2-16 16v48H480V80c0-8.8-7.2-16-16-16s-16 7.2-16 16v48H432c-8.8 0-16 7.2-16 16v32c0 35.8 23.5 66.1 56 76.3V376c0 13.3-10.7 24-24 24s-24-10.7-24-24V344c0-48.6-39.4-88-88-88H320V64c0-35.3-28.7-64-64-64H96zM216.9 82.7c6 4 8.5 11.5 6.3 18.3l-25 74.9H256c6.7 0 12.7 4.2 15 10.4s.5 13.3-4.6 17.7l-112 96c-5.5 4.7-13.4 5.1-19.3 1.1s-8.5-11.5-6.3-18.3l25-74.9H96c-6.7 0-12.7-4.2-15-10.4s-.5-13.3 4.6-17.7l112-96c5.5-4.7 13.4-5.1 19.3-1.1z';
  const WALL_SCONCE_PATH = 'M272 384c9.6-31.9 29.5-59.1 49.2-86.2l0 0c5.2-7.1 10.4-14.2 15.4-21.4c19.8-28.5 31.4-63 31.4-100.3C368 78.8 289.2 0 192 0S16 78.8 16 176c0 37.3 11.6 71.9 31.4 100.3c5 7.2 10.2 14.3 15.4 21.4l0 0c19.8 27.1 39.7 54.4 49.2 86.2H272zM192 512c44.2 0 80-35.8 80-80V416H112v16c0 44.2 35.8 80 80 80z';

  const ICONS = [
    { value: WC_PATH, terms: ['water','closet','wc','toilet','bathroom'], name: 'Water Closet' },
    { value: WF_PATH, terms: ['water','fountain'], name: 'Water Fountain' },
    { value: SINK_PATH, terms: ['sink','faucet','basin'], name: 'Sink' },
    { value: HOSE_BIB_PATH, terms: ['hose','bib','spigot','faucet','outdoor'], name: 'Hose Bib' },
    { value: SHOWER_PATH, terms: ['shower','showerhead'], name: 'Shower' },
    { value: BATH_PATH, terms: ['bath','bathtub'], name: 'Bath' },
    { value: LAUNDRY_PATH, terms: ['laundry','washer','washing','machine'], name: 'Laundry' },
    { value: WATER_HEATER_PATH, terms: ['water','heater','hot'], name: 'Water Heater' },
    { value: CIRCLE_PATH, terms: ['circle','round','dot'], name: 'Circle' },
    { value: CIRCLE_DOT_PATH, terms: ['circle','dot','bullseye','target'], name: 'Circle Dot' },
    { value: LIGHT_PATH, terms: ['light','bulb','lamp'], name: 'Light' },
    { value: PLUG_PATH, terms: ['plug','outlet','electric','power'], name: 'Plug' },
    { value: POWER_PATH, terms: ['power','source','electric','bolt'], name: 'Power Source' },
    { value: BATTERY_PATH, terms: ['battery','cell','power'], name: 'Battery' },
    { value: CHARGING_PATH, terms: ['charging','station','ev','electric','vehicle'], name: 'Charging Station' },
    { value: WALL_SCONCE_PATH, terms: ['wall','sconce','light','fixture'], name: 'Wall Sconce' }
  ];

  function makeAnnotations() { return { counterMarkers: {}, polylines: [], quickLines: [] }; }

  <!-- SECTION: State -->
  const state = {
    pages: [], currentPage: 0, zoom: 1.0, tool: TOOL.NONE, scaleMode: SCALE_MODES.NONE,
    scalePointA: null, scalePointB: null, activeCounterType: null, activePolylineId: null, drawingPolyline: null,
    quickLineStart: null, mousePos: { x: 0, y: 0 }, pan: { x: 0, y: 0 }, isPanning: false, panStart: null,
    counters: [], lineTypes: [], activeLineTypeId: null, ctxTarget: null, selectedLineId: null, selectedLineIsPoly: false, selectedLinePageIdx: null,
    counterSettings: { size: 20, opacity: 1, showRings: false, numberSize: 10, ringSize: 1, ringOpacity: 1, ringSolid: false, outlineSize: 0 },
    pagesListCollapsed: false,
    lineTypeSettings: { opacity: 1, lineSize: 2 },
    exportSettings: { markerScale: 0.75, lineScale: 0.75 },
    recentLineColors: [],
    editingPolyline: null, editingPolyIndex: null, draggingVertexIdx: null, longPressTimer: null, longPressFired: false,
    longPressStart: null, pinchStartDistance: null, pinchStartZoom: null
  };

  <!-- SECTION: Math & Format Helpers -->
  function ptDist(a, b) { return Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2); }
  function polylineDistance(pts, closed) {
    let d = 0;
    for (let i = 0; i < pts.length - 1; i++) d += ptDist(pts[i], pts[i + 1]);
    if (closed && pts.length >= 3) d += ptDist(pts[pts.length - 1], pts[0]);
    return d;
  }
  function polygonArea(pts) {
    let sum = 0;
    for (let i = 0; i < pts.length; i++) {
      const j = (i + 1) % pts.length;
      sum += pts[i].x * pts[j].y - pts[j].x * pts[i].y;
    }
    return Math.abs(sum) / 2;
  }
  function distToSegment(p, a, b) {
    const dx = b.x - a.x, dy = b.y - a.y, len = Math.sqrt(dx * dx + dy * dy);
    if (len === 0) return ptDist(p, a);
    let t = ((p.x - a.x) * dx + (p.y - a.y) * dy) / (len * len);
    t = Math.max(0, Math.min(1, t));
    const q = { x: a.x + t * dx, y: a.y + t * dy };
    return ptDist(p, q);
  }
  function getPageScale(pi) { return state.pages[pi]?.scale ?? null; }
  function formatDist(pdfPts, scale) {
    scale = scale ?? getPageScale(state.currentPage);
    if (!scale) return Math.round(pdfPts) + ' px';
    return (pdfPts / scale.pixelsPerUnit).toFixed(2) + ' ' + scale.unit;
  }
  function formatArea(sqPdfPts, scale) {
    scale = scale ?? getPageScale(state.currentPage);
    if (!scale) return Math.round(sqPdfPts) + ' px²';
    const ppu = scale.pixelsPerUnit;
    return (sqPdfPts / (ppu * ppu)).toFixed(1) + ' ' + scale.unit + '²';
  }

  function getClientCoords(e) {
    if (e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    if (e.changedTouches && e.changedTouches.length) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  const canvasWrapper = document.getElementById('canvasWrapper');
  const canvasContainer = document.getElementById('canvasContainer');
  const pdfCanvas = document.getElementById('pdfCanvas');
  const annCanvas = document.getElementById('annCanvas');

  function canvasRect() {
    const w = canvasWrapper || document.querySelector('.canvas-wrapper');
    const el = w || document.body;
    const r = (el && el.getBoundingClientRect) ? el.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
    return r;
  }

  const dpr = () => window.devicePixelRatio || 1;
  function toCanvas(p) { const scale = state.zoom * dpr(); return { x: p.x * scale, y: p.y * scale }; }
  function pdfPos(e) {
    const r = canvasRect();
    const el = document.querySelector('.canvas-wrapper');
    const rect = el ? el.getBoundingClientRect() : { left: 0, top: 0 };
    const cx = (getClientCoords(e).x - rect.left - state.pan.x) / state.zoom;
    const cy = (getClientCoords(e).y - rect.top - state.pan.y - (document.querySelector('.header')?.offsetHeight || 52)) / state.zoom;
    return { x: cx, y: cy };
  }

  function canvasToPdf(canvasX, canvasY) {
    const el = document.querySelector('.canvas-wrapper');
    const rect = el ? el.getBoundingClientRect() : { left: 0, top: 0 };
    return { x: (canvasX - state.pan.x) / state.zoom, y: (canvasY - state.pan.y) / state.zoom };
  }

  function hitTest(pos, radius = 12) {
    const r = radius / state.zoom;
    const page = state.pages[state.currentPage];
    if (!page) return null;
    const ann = page.annotations;
    for (const [typeId, markers] of Object.entries(ann.counterMarkers || {})) {
      for (let i = 0; i < markers.length; i++) {
        if (ptDist(pos, markers[i]) <= r) return { type: 'marker', typeId, index: i };
      }
    }
    for (let i = 0; i < (ann.quickLines || []).length; i++) {
      const q = ann.quickLines[i];
      if (distToSegment(pos, { x: q.x1, y: q.y1 }, { x: q.x2, y: q.y2 }) <= r) return { type: 'quickLine', index: i };
    }
    for (let i = 0; i < (ann.polylines || []).length; i++) {
      const poly = ann.polylines[i];
      const pts = poly.points || [];
      for (let j = 0; j < pts.length - 1; j++) {
        if (distToSegment(pos, pts[j], pts[j + 1]) <= r) return { type: 'polyline', index: i };
      }
      if (poly.closed && pts.length >= 3 && distToSegment(pos, pts[pts.length - 1], pts[0]) <= r) return { type: 'polyline', index: i };
    }
    return null;
  }

  function renderIconHtml(iconValue, color) {
    const vb = iconValue === LIGHT_PATH || iconValue === PLUG_PATH || iconValue === POWER_PATH || iconValue === BATTERY_PATH || iconValue === CHARGING_PATH || iconValue === WALL_SCONCE_PATH || iconValue === BATH_PATH || iconValue === LAUNDRY_PATH || iconValue === WATER_HEATER_PATH ? '0 0 512 512' : '0 0 640 640';
    return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="' + vb + '" width="24" height="24"><path fill="' + (color || '#e8c547') + '" d="' + iconValue + '"/></svg>';
  }

  function updateStatus() {
    const modeEl = document.getElementById('statusMode');
    const coordsEl = document.getElementById('statusCoords');
    let mode = 'Ready';
    if (state.tool === TOOL.SCALE) mode = state.scaleMode === SCALE_MODES.POINT_A ? 'Click first point' : 'Click second point';
    else if (state.tool === TOOL.LINE) mode = state.quickLineStart ? 'Click end point' : 'Click start point';
    else if (state.tool === TOOL.POLYLINE) mode = 'Click to add points';
    else if (state.tool === TOOL.COUNTER) mode = 'Click to place marker';
    else if (state.tool === TOOL.EDIT_POLY) mode = 'Edit polyline';
    if (modeEl) modeEl.textContent = mode;
    if (coordsEl) coordsEl.textContent = state.mousePos ? `(${Math.round(state.mousePos.x)}, ${Math.round(state.mousePos.y)})` : '—';
  }

  <!-- SECTION: Coordinate Helpers -->
  function canvasPointFromEvent(e) {
    const el = document.getElementById('canvasWrapper') || document.querySelector('.canvas-wrapper');
    const rect = el ? el.getBoundingClientRect() : { left: 0, top: 0 };
    const c = getClientCoords(e);
    return { x: c.x - rect.left, y: c.y - rect.top };
  }

  let pdfRenderTask = null;
  let pdfOffscreenCanvas = null;
  let pdfRenderId = 0;
  let pdfRenderPending = false;
  <!-- SECTION: PDF Rendering -->
  function renderPdf() {
    const page = state.pages[state.currentPage];
    if (!page || !page.pdfPage) return;
    if (pdfRenderTask) {
      pdfRenderPending = true;
      return;
    }
    pdfRenderPending = false;
    pdfRenderId++;
    const thisRenderId = pdfRenderId;
    const scale = state.zoom * (window.devicePixelRatio || 1);
    const viewport = page.pdfPage.getViewport({ scale });
    if (!pdfOffscreenCanvas) pdfOffscreenCanvas = document.createElement('canvas');
    pdfOffscreenCanvas.width = viewport.width;
    pdfOffscreenCanvas.height = viewport.height;
    pdfRenderTask = page.pdfPage.render({ canvasContext: pdfOffscreenCanvas.getContext('2d'), viewport });
    pdfRenderTask.promise.then(() => {
      pdfRenderTask = null;
      if (thisRenderId !== pdfRenderId) {
        if (pdfRenderPending) renderPdf();
        return;
      }
      lastRenderedZoom = state.zoom;
      updateContainerTransform();
      pdfCanvas.width = viewport.width;
      pdfCanvas.height = viewport.height;
      pdfCanvas.style.width = viewport.width / (window.devicePixelRatio || 1) + 'px';
      pdfCanvas.style.height = viewport.height / (window.devicePixelRatio || 1) + 'px';
      pdfCanvas.getContext('2d').drawImage(pdfOffscreenCanvas, 0, 0);
      renderAnnotations();
      if (pdfRenderPending) renderPdf();
    }).catch(err => {
      pdfRenderTask = null;
      if (err && err.name !== 'RenderingCancelledException') console.error(err);
      if (pdfRenderPending) renderPdf();
    });
  }

  function renderAnnotations() {
    const page = state.pages[state.currentPage];
    if (!page) return;
    annCanvas.width = pdfCanvas.width;
    annCanvas.height = pdfCanvas.height;
    annCanvas.style.width = pdfCanvas.style.width;
    annCanvas.style.height = pdfCanvas.style.height;
    const ctx = annCanvas.getContext('2d');
    const z = state.zoom;
    ctx.clearRect(0, 0, annCanvas.width, annCanvas.height);
    const ann = page.annotations;
    if (state.scalePointA) {
      const a = toCanvas(state.scalePointA), b = toCanvas(state.scalePointB || state.scalePointA);
      ctx.strokeStyle = '#e8c547'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
      [state.scalePointA, state.scalePointB].filter(Boolean).forEach(pt => {
        const p = toCanvas(pt);
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.scale(24 / 640, 24 / 640);
        ctx.translate(-320, -320);
        ctx.fillStyle = '#e8c547';
        ctx.fill(new Path2D(SCALE_CROSSHAIR_PATH));
        ctx.restore();
      });
    }
    const lts = state.lineTypeSettings || { opacity: 1, lineSize: 2 };
    const lw = lts.lineSize || 2;
    const lo = lts.opacity != null ? lts.opacity : 1;
    const sel = state.selectedLineId && state.currentPage === state.selectedLinePageIdx;
    (ann.quickLines || []).forEach(q => {
      const a = toCanvas({ x: q.x1, y: q.y1 }), b = toCanvas({ x: q.x2, y: q.y2 });
      const isSelected = sel && !state.selectedLineIsPoly && state.selectedLineId === q.id;
      ctx.strokeStyle = q.color || '#4a9eff'; ctx.lineWidth = isSelected ? lw * 2 : lw; ctx.globalAlpha = lo;
      if (isSelected) { ctx.shadowBlur = 8; ctx.shadowColor = q.color || '#4a9eff'; }
      ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
      if (isSelected) { ctx.shadowBlur = 0; ctx.shadowColor = 'transparent'; }
      ctx.globalAlpha = 1;
    });
    (ann.polylines || []).forEach(poly => {
      const pts = poly.points || [];
      if (pts.length < 2) return;
      const isSelected = sel && state.selectedLineIsPoly && state.selectedLineId === poly.id;
      ctx.strokeStyle = poly.color || '#4a9eff'; ctx.lineWidth = isSelected ? lw * 2 : lw; ctx.globalAlpha = lo;
      if (isSelected) { ctx.shadowBlur = 8; ctx.shadowColor = poly.color || '#4a9eff'; }
      ctx.beginPath();
      const p0 = toCanvas(pts[0]); ctx.moveTo(p0.x, p0.y);
      for (let i = 1; i < pts.length; i++) { const p = toCanvas(pts[i]); ctx.lineTo(p.x, p.y); }
      if (poly.closed) ctx.closePath();
      ctx.stroke();
      if (isSelected) { ctx.shadowBlur = 0; ctx.shadowColor = 'transparent'; }
      ctx.globalAlpha = 1;
    });
    const FA_PATHS = [BATH_PATH, LAUNDRY_PATH, WATER_HEATER_PATH, LIGHT_PATH, PLUG_PATH, POWER_PATH, BATTERY_PATH, CHARGING_PATH, WALL_SCONCE_PATH];
    const RING_PATH = 'M528 320C528 205.1 434.9 112 320 112C205.1 112 112 205.1 112 320C112 434.9 205.1 528 320 528C434.9 528 528 434.9 528 320zM64 320C64 178.6 178.6 64 320 64C461.4 64 576 178.6 576 320C576 461.4 461.4 576 320 576C178.6 576 64 461.4 64 320z';
    const cs = state.counterSettings || { size: 20, opacity: 1, showRings: false, numberSize: 10, ringSize: 1, ringOpacity: 1, ringSolid: false, outlineSize: 0 };
    const s = cs.size;
    const opacity = cs.opacity;
    Object.entries(ann.counterMarkers || {}).forEach(([typeId, markers]) => {
      const def = state.counters.find(c => c.id === typeId);
      const iconPath = def ? def.icon : CIRCLE_PATH;
      const color = def ? def.color : '#e8c547';
      const vb = FA_PATHS.includes(iconPath) ? 512 : 640;
      markers.forEach((m, i) => {
        const p = toCanvas(m);
        if (cs.showRings) {
          const ringScale = (cs.ringSize || 100) / 100;
          const ringSizePx = s * ringScale;
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.scale(ringSizePx / 640, ringSizePx / 640);
          ctx.translate(-320, -320);
          ctx.globalAlpha = cs.ringOpacity != null ? cs.ringOpacity : 1;
          if (cs.ringSolid) {
            ctx.fillStyle = color;
            ctx.fill(new Path2D(RING_PATH));
          } else {
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke(new Path2D(RING_PATH));
          }
          ctx.globalAlpha = 1;
          ctx.restore();
        }
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.scale(s / vb, s / vb);
        ctx.translate(-vb / 2, -vb / 2);
        const path = new Path2D(iconPath);
        const outlineSize = cs.outlineSize != null ? cs.outlineSize : 0;
        if (outlineSize > 0) {
          ctx.strokeStyle = '#000';
          ctx.lineWidth = outlineSize * vb / s;
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.stroke(path);
        }
        ctx.fillStyle = color;
        ctx.globalAlpha = opacity;
        ctx.fill(path);
        ctx.globalAlpha = 1;
        ctx.restore();
        if (markers.length > 1) {
          const ns = (cs.numberSize || 10);
          ctx.fillStyle = '#000'; ctx.font = ns + 'px DM Sans'; ctx.fillText(String(i + 1), p.x + ns * 0.6, p.y - ns * 0.6);
        }
      });
    });
    if (state.quickLineStart && state.mousePos) {
      const lt = state.lineTypes.find(l => l.id === state.activeLineTypeId);
      const a = toCanvas(state.quickLineStart), b = toCanvas(state.mousePos);
      ctx.strokeStyle = lt?.color || '#4a9eff'; ctx.lineWidth = lw; ctx.globalAlpha = lo; ctx.setLineDash([4, 4]);
      ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke(); ctx.setLineDash([]); ctx.globalAlpha = 1;
    }
    if (state.drawingPolyline && state.drawingPolyline.points.length >= 1) {
      const pts = state.drawingPolyline.points;
      ctx.strokeStyle = state.drawingPolyline.color || '#4a9eff'; ctx.lineWidth = lw; ctx.globalAlpha = lo; ctx.setLineDash([4, 4]);
      ctx.beginPath();
      const p0 = toCanvas(pts[0]); ctx.moveTo(p0.x, p0.y);
      for (let i = 1; i < pts.length; i++) { const p = toCanvas(pts[i]); ctx.lineTo(p.x, p.y); }
      if (state.mousePos) { const pm = toCanvas(state.mousePos); ctx.lineTo(pm.x, pm.y); }
      ctx.stroke(); ctx.setLineDash([]); ctx.globalAlpha = 1;
    }
    if (state.editingPolyline) {
      const pts = state.editingPolyline.points || [];
      pts.forEach((pt, i) => {
        const p = toCanvas(pt);
        ctx.fillStyle = '#e8c547'; ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.stroke();
      });
    }
  }

  function renderAnnotationsToContext(ctx, page, scale, exportOverrides) {
    const tc = (p) => ({ x: p.x * scale, y: p.y * scale });
    const ann = page.annotations || makeAnnotations();
    const lts = state.lineTypeSettings || { opacity: 1, lineSize: 2 };
    const lineScale = exportOverrides?.lineScale ?? 1;
    const markerScale = exportOverrides?.markerScale ?? 1;
    let lw = (lts.lineSize || 2) * scale * lineScale;
    const lo = lts.opacity != null ? lts.opacity : 1;
    (ann.quickLines || []).forEach(q => {
      const a = tc({ x: q.x1, y: q.y1 }), b = tc({ x: q.x2, y: q.y2 });
      ctx.strokeStyle = q.color || '#4a9eff'; ctx.lineWidth = lw; ctx.globalAlpha = lo;
      ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
      ctx.globalAlpha = 1;
    });
    (ann.polylines || []).forEach(poly => {
      const pts = poly.points || [];
      if (pts.length < 2) return;
      ctx.strokeStyle = poly.color || '#4a9eff'; ctx.lineWidth = lw; ctx.globalAlpha = lo;
      ctx.beginPath();
      const p0 = tc(pts[0]); ctx.moveTo(p0.x, p0.y);
      for (let i = 1; i < pts.length; i++) { const p = tc(pts[i]); ctx.lineTo(p.x, p.y); }
      if (poly.closed) ctx.closePath();
      ctx.stroke();
      ctx.globalAlpha = 1;
    });
    const FA_PATHS = [BATH_PATH, LAUNDRY_PATH, WATER_HEATER_PATH, LIGHT_PATH, PLUG_PATH, POWER_PATH, BATTERY_PATH, CHARGING_PATH, WALL_SCONCE_PATH];
    const RING_PATH = 'M528 320C528 205.1 434.9 112 320 112C205.1 112 112 205.1 112 320C112 434.9 205.1 528 320 528C434.9 528 528 434.9 528 320zM64 320C64 178.6 178.6 64 320 64C461.4 64 576 178.6 576 320C576 461.4 461.4 576 320 576C178.6 576 64 461.4 64 320z';
    const cs = state.counterSettings || { size: 20, opacity: 1, showRings: false, numberSize: 10, ringSize: 1, ringOpacity: 1, ringSolid: false, outlineSize: 0 };
    const s = (cs.size || 20) * scale * markerScale;
    const opacity = cs.opacity;
    Object.entries(ann.counterMarkers || {}).forEach(([typeId, markers]) => {
      const def = state.counters.find(c => c.id === typeId);
      const iconPath = def ? def.icon : CIRCLE_PATH;
      const color = def ? def.color : '#e8c547';
      const vb = FA_PATHS.includes(iconPath) ? 512 : 640;
      markers.forEach((m, i) => {
        const p = tc(m);
        if (cs.showRings) {
          const ringScale = (cs.ringSize || 100) / 100;
          const ringSizePx = s * ringScale;
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.scale(ringSizePx / 640, ringSizePx / 640);
          ctx.translate(-320, -320);
          ctx.globalAlpha = cs.ringOpacity != null ? cs.ringOpacity : 1;
          if (cs.ringSolid) {
            ctx.fillStyle = color;
            ctx.fill(new Path2D(RING_PATH));
          } else {
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke(new Path2D(RING_PATH));
          }
          ctx.globalAlpha = 1;
          ctx.restore();
        }
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.scale(s / vb, s / vb);
        ctx.translate(-vb / 2, -vb / 2);
        const path = new Path2D(iconPath);
        const outlineSize = (cs.outlineSize != null ? cs.outlineSize : 0) * scale * markerScale;
        if (outlineSize > 0) {
          ctx.strokeStyle = '#000';
          ctx.lineWidth = outlineSize * vb / s;
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.stroke(path);
        }
        ctx.fillStyle = color;
        ctx.globalAlpha = opacity;
        ctx.fill(path);
        ctx.globalAlpha = 1;
        ctx.restore();
        if (markers.length > 1) {
          const ns = (cs.numberSize || 10) * scale * markerScale;
          ctx.fillStyle = '#000'; ctx.font = ns + 'px DM Sans'; ctx.fillText(String(i + 1), p.x + ns * 0.6, p.y - ns * 0.6);
        }
      });
    });
  }

  function getPageSize() {
    const page = state.pages[state.currentPage];
    if (!page || !page.pdfPage) return { w: 0, h: 0 };
    const vp = page.pdfPage.getViewport({ scale: state.zoom });
    return { w: vp.width, h: vp.height };
  }

  function fitZoom() {
    const page = state.pages[state.currentPage];
    if (!page || !page.pdfPage) return;
    const wrap = document.querySelector('.canvas-wrapper');
    if (!wrap) return;
    const r = wrap.getBoundingClientRect();
    const vp = page.pdfPage.getViewport({ scale: 1 });
    const scaleX = r.width / vp.width, scaleY = r.height / vp.height;
    state.zoom = Math.max(0.2, Math.min(8, Math.min(scaleX, scaleY)));
    state.pan = { x: 0, y: 0 };
    renderPdf();
    updateUI();
  }

  <!-- SECTION: UI Render Functions -->
  function updateUI() {
    document.getElementById('zoomPct').textContent = Math.round(state.zoom * 100) + '%';
    document.getElementById('pageInfo').textContent = 'Page ' + (state.pages.length ? state.currentPage + 1 : 0) + ' of ' + (state.pages.length || 0);
    document.getElementById('prevPage').disabled = state.currentPage <= 0;
    document.getElementById('nextPage').disabled = state.currentPage >= state.pages.length - 1;
    const setScaleBtn = document.getElementById('setScale');
    const scale = getPageScale(state.currentPage);
    if (scale) {
      setScaleBtn.classList.add('scale-set');
      setScaleBtn.innerHTML = 'Scale<br><span class="scale-value">1 ' + scale.unit + ' = ' + scale.pixelsPerUnit.toFixed(1) + '</span>';
    } else {
      setScaleBtn.classList.remove('scale-set');
      setScaleBtn.textContent = 'Set Scale';
    }
    document.getElementById('moveBtn').classList.toggle('active', state.tool === TOOL.NONE);
    document.getElementById('quickLine').classList.toggle('active', state.tool === TOOL.LINE);
    document.getElementById('polylineBtn').classList.toggle('active', state.tool === TOOL.POLYLINE);
    document.getElementById('counterBtn').classList.toggle('active', state.tool === TOOL.COUNTER);
    document.getElementById('setScale').classList.toggle('active', state.tool === TOOL.SCALE);
    document.getElementById('doneEditing').style.display = state.tool === TOOL.EDIT_POLY ? 'block' : 'none';
    document.getElementById('polylineFinishBar').classList.toggle('visible', !!state.drawingPolyline);
    renderPagesList();
    renderCountersList();
    renderLineTypesList();
    renderLinesList();
    renderSummary();
    updateStatus();
  }

  function renderPagesList() {
    const el = document.getElementById('pagesList');
    el.innerHTML = '';
    state.pages.forEach((p, i) => {
      const div = document.createElement('div');
      div.className = 'sidebar-item';
      const hasAnn = (p.annotations?.counterMarkers && Object.keys(p.annotations.counterMarkers).length) || (p.annotations?.quickLines?.length) || (p.annotations?.polylines?.length);
      const hasScale = !!p.scale;
      div.innerHTML = '<span class="badge' + (hasScale ? ' badge-scale-set' : '') + '">' + (i + 1) + '</span><span class="name">' + (p.label || 'Page ' + (i + 1)) + '</span>' + (hasAnn ? ' <span style="color:var(--accent)">•</span>' : '') + '<span class="edit-btn" title="Rename">✎</span>';
      div.onclick = (e) => { if (!e.target.closest('.edit-btn')) { state.currentPage = i; renderPdf(); updateUI(); } };
      div.querySelector('.edit-btn')?.addEventListener('click', (e) => { e.stopPropagation(); startRename(div.querySelector('.name'), (v) => { p.label = v; updateUI(); }); });
      onDoubleTapOrDblClick(div.querySelector('.name'), () => { startRename(div.querySelector('.name'), (v) => { p.label = v; updateUI(); }); });
      el.appendChild(div);
    });
  }

  function renderCountersList() {
    const el = document.getElementById('countersList');
    el.innerHTML = '';
    state.counters.forEach(c => {
      const div = document.createElement('div');
      div.className = 'sidebar-item' + (state.activeCounterType === c.id ? ' active' : '');
      const count = state.pages.reduce((n, p) => n + ((p.annotations?.counterMarkers?.[c.id] || []).length), 0);
      div.innerHTML = '<span class="icon-svg"><svg viewBox="' + iconVbFor(c.icon) + '" width="20" height="20"><path fill="' + c.color + '" d="' + c.icon + '"/></svg></span><span class="name">' + (c.name || 'Counter') + '</span><span class="badge">' + count + '</span><span class="swatch" style="background:' + c.color + '"></span><span class="edit-btn" title="Rename">✎</span>';
      div.onclick = (e) => { if (!e.target.closest('.swatch') && !e.target.closest('.edit-btn')) { state.activeCounterType = state.activeCounterType === c.id ? null : c.id; state.tool = state.activeCounterType ? TOOL.COUNTER : TOOL.NONE; updateUI(); } };
      div.querySelector('.swatch')?.addEventListener('click', (e) => { e.stopPropagation(); showLineColorModal(c.color || '#e8c547', (color) => { c.color = color; }); });
      div.querySelector('.edit-btn')?.addEventListener('click', (e) => { e.stopPropagation(); startRename(div.querySelector('.name'), (v) => { c.name = v; updateUI(); }); });
      onDoubleTapOrDblClick(div.querySelector('.name'), () => { startRename(div.querySelector('.name'), (v) => { c.name = v; updateUI(); }); });
      el.appendChild(div);
    });
  }

  function renderLineTypesList() {
    const el = document.getElementById('lineTypesList');
    el.innerHTML = '';
    state.lineTypes.forEach(lt => {
      const runs = state.pages.reduce((n, p) => {
        const q = (p.annotations?.quickLines || []).filter(q => q.lineTypeId === lt.id).length;
        const poly = (p.annotations?.polylines || []).filter(poly => poly.lineTypeId === lt.id).length;
        return n + q + poly;
      }, 0);
      let len = 0;
      state.pages.forEach(p => {
        (p.annotations?.quickLines || []).filter(q => q.lineTypeId === lt.id).forEach(q => len += ptDist({ x: q.x1, y: q.y1 }, { x: q.x2, y: q.y2 }));
        (p.annotations?.polylines || []).filter(poly => poly.lineTypeId === lt.id).forEach(poly => len += polylineDistance(poly.points || [], poly.closed));
      });
      const div = document.createElement('div');
      div.className = 'sidebar-item sidebar-item-line-type' + (state.activeLineTypeId === lt.id ? ' active' : '');
      div.innerHTML = '<span class="name line-type-name">' + (lt.name || 'Line') + '</span><div class="line-type-row"><span class="swatch" style="background:' + lt.color + '"></span><span class="badge">' + runs + ' · ' + formatDist(len, null) + '</span><span class="edit-btn" title="Rename">✎</span></div>';
      div.onclick = (e) => { if (!e.target.closest('.swatch') && !e.target.closest('.edit-btn')) { state.activeLineTypeId = state.activeLineTypeId === lt.id ? null : lt.id; updateUI(); } };
      div.querySelector('.swatch')?.addEventListener('click', (e) => { e.stopPropagation(); showLineColorModal(lt.color || '#4a9eff', (color) => { lt.color = color; }); });
      div.querySelector('.edit-btn')?.addEventListener('click', (e) => { e.stopPropagation(); startRename(div.querySelector('.name'), (v) => { lt.name = v; updateUI(); }); });
      onDoubleTapOrDblClick(div.querySelector('.name'), () => { startRename(div.querySelector('.name'), (v) => { lt.name = v; updateUI(); }); });
      el.appendChild(div);
    });
  }

  function renderLinesList() {
    const el = document.getElementById('linesList');
    el.innerHTML = '';
    const byType = {};
    state.pages.forEach((p, pi) => {
      (p.annotations?.polylines || []).forEach(poly => {
        const tid = poly.lineTypeId || '_none';
        if (!byType[tid]) byType[tid] = [];
        byType[tid].push({ type: 'poly', poly, pageIdx: pi });
      });
      (p.annotations?.quickLines || []).forEach(q => {
        const tid = q.lineTypeId || '_none';
        if (!byType[tid]) byType[tid] = [];
        byType[tid].push({ type: 'quick', q, pageIdx: pi });
      });
    });
    Object.entries(byType).forEach(([tid, items]) => {
      const lt = tid === '_none' ? null : state.lineTypes.find(l => l.id === tid);
      if (lt) {
        const h = document.createElement('div');
        h.className = 'sidebar-section';
        h.style.padding = '4px 0';
        h.innerHTML = '<h3 style="font-size:0.7rem;color:var(--text3);">' + (lt.name || 'Line') + '</h3>';
        el.appendChild(h);
      }
      items.forEach(it => {
      const lineId = it.type === 'poly' ? it.poly.id : it.q.id;
      const isSelected = state.selectedLineId === lineId && state.selectedLinePageIdx === it.pageIdx;
      const div = document.createElement('div');
      div.className = 'sidebar-item sidebar-item-line-type' + (isSelected ? ' active' : '');
      const lt = state.lineTypes.find(l => l.id === (it.type === 'poly' ? it.poly.lineTypeId : it.q.lineTypeId));
      const color = (it.type === 'poly' ? it.poly.color : it.q.color) || (lt?.color || '#4a9eff');
      const pageScale = state.pages[it.pageIdx]?.scale;
      let dist, name;
      if (it.type === 'poly') {
        dist = it.poly.closed ? formatArea(polygonArea(it.poly.points || []), pageScale) : formatDist(polylineDistance(it.poly.points || [], false), pageScale);
        name = it.poly.name || 'Polyline';
      } else {
        dist = formatDist(ptDist({ x: it.q.x1, y: it.q.y1 }, { x: it.q.x2, y: it.q.y2 }), pageScale);
        name = it.q.name || 'Quick line';
      }
      div.innerHTML = '<span class="name line-type-name">' + name + '</span><div class="line-type-row"><span class="swatch" style="background:' + color + '"></span><span class="badge">' + dist + '</span><span class="edit-btn" title="' + (it.type === 'poly' ? 'Edit vertices' : 'Rename') + '">✎</span></div>';
      div.onclick = (e) => {
        if (e.target.closest('.swatch') || e.target.closest('.edit-btn')) return;
        if (isSelected) {
          state.selectedLineId = null;
          state.selectedLineIsPoly = false;
          state.selectedLinePageIdx = null;
        } else if (lineId) {
          state.selectedLineId = lineId;
          state.selectedLineIsPoly = it.type === 'poly';
          state.selectedLinePageIdx = it.pageIdx;
          state.currentPage = it.pageIdx;
        }
        updateUI();
        renderPdf();
      };
      const swatch = div.querySelector('.swatch');
      if (swatch) swatch.addEventListener('click', (e) => {
        e.stopPropagation();
        showLineColorModal(
          (it.type === 'poly' ? it.poly.color : it.q.color) || (lt?.color || '#4a9eff'),
          (color) => {
            if (it.type === 'poly') it.poly.color = color;
            else it.q.color = color;
          }
        );
      });
      const editBtn = div.querySelector('.edit-btn');
      if (it.type === 'poly') editBtn.onclick = (e) => { e.stopPropagation(); enterEditMode(it.poly.id, it.pageIdx); };
      else editBtn.onclick = (e) => { e.stopPropagation(); startRename(div.querySelector('.name'), (v) => { it.q.name = v; updateUI(); }); };
      onDoubleTapOrDblClick(div.querySelector('.name'), () => {
        if (it.type === 'poly') startRename(div.querySelector('.name'), (v) => { it.poly.name = v; updateUI(); });
        else startRename(div.querySelector('.name'), (v) => { it.q.name = v; updateUI(); });
      });
      el.appendChild(div);
    });
    });
  }

  function renderSummary() {
    const el = document.getElementById('summaryList');
    el.innerHTML = '';
    state.counters.forEach(c => {
      const count = state.pages.reduce((n, p) => n + ((p.annotations?.counterMarkers?.[c.id] || []).length), 0);
      if (count > 0) el.innerHTML += '<div class="sidebar-item"><span class="name">' + c.name + '</span><span class="badge">' + count + '</span></div>';
    });
    state.lineTypes.forEach(lt => {
      let runs = 0, len = 0;
      state.pages.forEach(p => {
        (p.annotations?.quickLines || []).filter(q => q.lineTypeId === lt.id).forEach(q => { runs++; len += ptDist({ x: q.x1, y: q.y1 }, { x: q.x2, y: q.y2 }); });
        (p.annotations?.polylines || []).filter(poly => poly.lineTypeId === lt.id).forEach(poly => { runs++; len += polylineDistance(poly.points || [], poly.closed); });
      });
      if (runs > 0) el.innerHTML += '<div class="sidebar-item"><span class="name">' + lt.name + '</span><span class="badge">' + runs + ' · ' + formatDist(len, null) + '</span></div>';
    });
  }

  function onDoubleTapOrDblClick(el, handler) {
    if (!el) return;
    let lastTap = 0;
    el.addEventListener('click', (e) => {
      const now = Date.now();
      if (now - lastTap < 400) { e.preventDefault(); handler(); lastTap = 0; }
      else lastTap = now;
    });
    el.addEventListener('dblclick', (e) => { e.preventDefault(); handler(); });
  }

  function startRename(el, onSave) {
    if (!el) return;
    const span = el.tagName === 'SPAN' ? el : el.querySelector('.name');
    if (!span) return;
    const originalText = span.textContent;
    const inp = document.createElement('input');
    inp.type = 'text';
    inp.value = originalText;
    inp.className = 'rename-input';
    inp.style.cssText = 'width:100%;background:var(--surface2);border:1px solid var(--border);color:var(--text);padding:4px;';
    span.replaceWith(inp);
    inp.focus();
    inp.setSelectionRange(inp.value.length, inp.value.length);
    inp.onclick = inp.onmousedown = inp.onmouseup = (e) => e.stopPropagation();
    inp.onblur = () => {
      if (inp.dataset.cancelled) return;
      const v = inp.value.trim();
      if (v) onSave(v);
      inp.replaceWith(span);
      span.textContent = v || originalText;
      updateUI();
    };
    inp.onkeydown = (e) => {
      if (e.key === 'Enter') inp.blur();
      if (e.key === 'Escape') {
        inp.dataset.cancelled = '1';
        span.textContent = originalText;
        inp.replaceWith(span);
        updateUI();
      }
    };
  }

  function enterEditMode(polyId, pageIdx) {
    const page = state.pages[pageIdx];
    const idx = (page.annotations?.polylines || []).findIndex(p => p.id === polyId);
    if (idx < 0) return;
    state.editingPolyline = page.annotations.polylines.splice(idx, 1)[0];
    state.editingPolyIndex = pageIdx;
    state.tool = TOOL.EDIT_POLY;
    state.activePolylineId = polyId;
    state.selectedLineId = null;
    state.selectedLineIsPoly = false;
    state.selectedLinePageIdx = null;
    annCanvas.classList.add('interactive');
    updateUI();
    renderAnnotations();
  }

  function exitEditMode(save) {
    if (!state.editingPolyline) return;
    if (save && (state.editingPolyline.points || []).length >= 2) {
      const page = state.pages[state.editingPolyIndex];
      if (page && page.annotations) page.annotations.polylines.push(state.editingPolyline);
    }
    state.editingPolyline = null;
    state.editingPolyIndex = null;
    state.activePolylineId = null;
    state.tool = TOOL.NONE;
    state.draggingVertexIdx = null;
    annCanvas.classList.remove('interactive');
    updateUI();
    renderPdf();
  }

  function showModal(id) { document.getElementById(id).classList.add('visible'); }
  function hideModal(id) { document.getElementById(id).classList.remove('visible'); }

  let setScaleFirstToastTimer = null;
  function showSetScaleFirstToast() {
    if (setScaleFirstToastTimer) clearTimeout(setScaleFirstToastTimer);
    showModal('setScaleFirstModal');
    setScaleFirstToastTimer = setTimeout(() => {
      hideModal('setScaleFirstModal');
      setScaleFirstToastTimer = null;
    }, 3000);
  }

  let setScaleFirstPolylineToastTimer = null;
  function showSetScaleFirstPolylineToast() {
    if (setScaleFirstPolylineToastTimer) clearTimeout(setScaleFirstPolylineToastTimer);
    showModal('setScaleFirstPolylineModal');
    setScaleFirstPolylineToastTimer = setTimeout(() => {
      hideModal('setScaleFirstPolylineModal');
      setScaleFirstPolylineToastTimer = null;
    }, 3000);
  }

  let addLineTypeFirstToastTimer = null;
  function showAddLineTypeFirstToast() {
    if (addLineTypeFirstToastTimer) clearTimeout(addLineTypeFirstToastTimer);
    showModal('addLineTypeFirstModal');
    addLineTypeFirstToastTimer = setTimeout(() => {
      hideModal('addLineTypeFirstModal');
      addLineTypeFirstToastTimer = null;
    }, 3000);
  }

  function showSelectLineTypeModal() {
    const el = document.getElementById('selectLineTypeList');
    el.innerHTML = '';
    state.lineTypes.forEach(lt => {
      const div = document.createElement('div');
      div.className = 'sidebar-item sidebar-item-line-type';
      div.innerHTML = '<span class="name line-type-name">' + (lt.name || 'Line') + '</span><span class="swatch" style="background:' + (lt.color || '#4a9eff') + '"></span>';
      div.onclick = () => {
        state.activeLineTypeId = lt.id;
        hideModal('selectLineTypeModal');
        state.tool = TOOL.LINE;
        state.quickLineStart = null;
        updateUI();
      };
      el.appendChild(div);
    });
    showModal('selectLineTypeModal');
  }

  function showLineColorModal(currentColor, onApply) {
    state.pendingLineColorApply = onApply;
    const inp = document.getElementById('lineColorCustom');
    inp.value = currentColor || '#4a9eff';
    const recentEl = document.getElementById('lineColorRecent');
    const recentGroup = document.getElementById('lineColorRecentGroup');
    recentEl.innerHTML = '';
    (state.recentLineColors || []).forEach(c => {
      const s = document.createElement('span');
      s.className = 'color-swatch';
      s.style.background = c;
      s.dataset.color = c;
      s.onclick = () => applyLineColor(c);
      recentEl.appendChild(s);
    });
    recentGroup.style.display = (state.recentLineColors || []).length ? 'block' : 'none';
    showModal('lineColorModal');
  }
  function applyLineColor(color) {
    if (state.pendingLineColorApply) {
      state.pendingLineColorApply(color);
      state.recentLineColors = [color].concat((state.recentLineColors || []).filter(c => c !== color)).slice(0, 12);
      state.pendingLineColorApply = null;
      hideModal('lineColorModal');
      updateUI();
      renderPdf();
    }
  }

  <!-- SECTION: Modals & Handlers -->
  document.getElementById('uploadPdf').onclick = () => document.getElementById('pdfInput').click();
  document.getElementById('pdfInput').onchange = async (e) => {
    const files = e.target.files;
    if (!files?.length) return;
    for (const f of files) {
      const buf = await f.arrayBuffer();
      const pdf = await pdfjsLib.getDocument(buf).promise;
      const numPages = pdf.numPages;
      for (let i = 0; i < numPages; i++) {
        const pdfPage = await pdf.getPage(i + 1);
        const label = numPages > 1 ? (f.name + ' — p' + (i + 1)) : f.name;
        state.pages.push({ pdfPage, label, annotations: makeAnnotations(), scale: null });
      }
    }
    state.currentPage = state.pages.length - 1;
    renderPdf();
    updateUI();
    e.target.value = '';
  };

  document.getElementById('setScale').onclick = () => { state.tool = TOOL.SCALE; state.scaleMode = SCALE_MODES.POINT_A; state.scalePointA = null; state.scalePointB = null; updateUI(); };
  document.getElementById('moveBtn').onclick = () => {
    state.tool = TOOL.NONE;
    state.quickLineStart = null;
    state.activeCounterType = null;
    updateUI();
    renderPdf();
  };
  document.getElementById('quickLine').onclick = () => {
    if (!getPageScale(state.currentPage)) {
      showSetScaleFirstToast();
      return;
    }
    if (!state.lineTypes.length) {
      showAddLineTypeFirstToast();
      return;
    }
    if (!state.activeLineTypeId) {
      showSelectLineTypeModal();
      return;
    }
    state.tool = TOOL.LINE;
    state.quickLineStart = null;
    updateUI();
  };
  document.getElementById('polylineBtn').onclick = () => {
    if (!getPageScale(state.currentPage)) {
      showSetScaleFirstPolylineToast();
      return;
    }
    document.getElementById('polylineLineType').innerHTML = state.lineTypes.map(lt => '<option value="' + lt.id + '">' + lt.name + '</option>').join('') || '<option value="">—</option>';
    document.getElementById('polylineName').value = '';
    const cr = document.getElementById('polylineColorRow');
    cr.innerHTML = COLORS.map((c, i) => '<span class="color-swatch' + (i === 2 ? ' selected' : '') + '" data-color="' + c + '" style="background:' + c + '"></span>').join('');
    cr.querySelectorAll('.color-swatch').forEach(s => s.onclick = () => { cr.querySelectorAll('.color-swatch').forEach(x => x.classList.remove('selected')); s.classList.add('selected'); });
    showModal('polylineModal');
  };
  document.getElementById('counterBtn').onclick = () => {
    document.getElementById('counterName').value = '';
    document.getElementById('counterIconSearch').value = '';
    const grid = document.getElementById('counterIconGrid');
    grid.innerHTML = ICONS.map((ic, i) => '<div class="icon-cell' + (i === 0 ? ' selected' : '') + '" data-path="' + ic.value + '"><svg viewBox="' + iconVbFor(ic.value) + '" width="24" height="24"><path fill="currentColor" d="' + ic.value + '"/></svg></div>').join('');
    grid.querySelectorAll('.icon-cell').forEach(c => c.onclick = () => { grid.querySelectorAll('.icon-cell').forEach(x => x.classList.remove('selected')); c.classList.add('selected'); });
    const cr = document.getElementById('counterColorRow');
    cr.innerHTML = COLORS.map((c, i) => '<span class="color-swatch' + (i === 2 ? ' selected' : '') + '" data-color="' + c + '" style="background:' + c + '"></span>').join('');
    cr.querySelectorAll('.color-swatch').forEach(s => s.onclick = () => { cr.querySelectorAll('.color-swatch').forEach(x => x.classList.remove('selected')); s.classList.add('selected'); });
    showModal('counterModal');
  };
  document.getElementById('doneEditing').onclick = () => exitEditMode(true);

  document.getElementById('scaleCancel').onclick = () => hideModal('scaleModal');
  document.getElementById('scaleSet').onclick = () => {
    const val = parseFloat(document.getElementById('scaleValue').value);
    const unit = document.getElementById('scaleUnit').value;
    if (!val || !state.scalePointA || !state.scalePointB) return;
    const page = state.pages[state.currentPage];
    if (page) page.scale = { pixelsPerUnit: ptDist(state.scalePointA, state.scalePointB) / val, unit };
    state.tool = TOOL.NONE;
    state.scaleMode = SCALE_MODES.NONE;
    state.scalePointA = null;
    state.scalePointB = null;
    hideModal('scaleModal');
    updateUI();
    renderPdf();
  };

  const iconVbFor = (p) => [BATH_PATH, LAUNDRY_PATH, WATER_HEATER_PATH, LIGHT_PATH, PLUG_PATH, POWER_PATH, BATTERY_PATH, CHARGING_PATH, WALL_SCONCE_PATH].includes(p) ? '0 0 512 512' : '0 0 640 640';
  document.getElementById('addCounter').onclick = () => {
    document.getElementById('counterName').value = '';
    document.getElementById('counterIconSearch').value = '';
    const grid = document.getElementById('counterIconGrid');
    grid.innerHTML = ICONS.map((ic, i) => '<div class="icon-cell' + (i === 0 ? ' selected' : '') + '" data-path="' + ic.value + '"><svg viewBox="' + iconVbFor(ic.value) + '" width="24" height="24"><path fill="currentColor" d="' + ic.value + '"/></svg></div>').join('');
    grid.querySelectorAll('.icon-cell').forEach(c => c.onclick = () => { grid.querySelectorAll('.icon-cell').forEach(x => x.classList.remove('selected')); c.classList.add('selected'); });
    const cr = document.getElementById('counterColorRow');
    cr.innerHTML = COLORS.map((c, i) => '<span class="color-swatch' + (i === 2 ? ' selected' : '') + '" data-color="' + c + '" style="background:' + c + '"></span>').join('');
    cr.querySelectorAll('.color-swatch').forEach(s => s.onclick = () => { cr.querySelectorAll('.color-swatch').forEach(x => x.classList.remove('selected')); s.classList.add('selected'); });
    showModal('counterModal');
  };
  document.getElementById('counterIconSearch').oninput = () => {
    const q = document.getElementById('counterIconSearch').value.toLowerCase();
    const grid = document.getElementById('counterIconGrid');
    const filtered = q ? ICONS.filter(ic => ic.terms.some(t => t.includes(q))) : ICONS;
    grid.innerHTML = filtered.map((ic, i) => '<div class="icon-cell' + (i === 0 ? ' selected' : '') + '" data-path="' + ic.value + '"><svg viewBox="' + iconVbFor(ic.value) + '" width="24" height="24"><path fill="currentColor" d="' + ic.value + '"/></svg></div>').join('');
    grid.querySelectorAll('.icon-cell').forEach(c => c.onclick = () => { grid.querySelectorAll('.icon-cell').forEach(x => x.classList.remove('selected')); c.classList.add('selected'); });
  };
  document.getElementById('counterCancel').onclick = () => hideModal('counterModal');
  document.getElementById('counterCreate').onclick = () => {
    const name = document.getElementById('counterName').value.trim() || 'Counter';
    const sel = document.querySelector('#counterIconGrid .icon-cell.selected');
    const icon = sel ? sel.dataset.path : ICONS[0].value;
    const colorSel = document.querySelector('#counterColorRow .color-swatch.selected');
    const color = colorSel ? colorSel.dataset.color : COLORS[2];
    state.counters.push({ id: uid(), name, icon, color });
    hideModal('counterModal');
    updateUI();
  };

  document.getElementById('addLineType').onclick = () => {
    document.getElementById('lineTypeName').value = '';
    const cr = document.getElementById('lineTypeColorRow');
    cr.innerHTML = COLORS.map((c, i) => '<span class="color-swatch' + (i === 2 ? ' selected' : '') + '" data-color="' + c + '" style="background:' + c + '"></span>').join('');
    cr.querySelectorAll('.color-swatch').forEach(s => s.onclick = () => { cr.querySelectorAll('.color-swatch').forEach(x => x.classList.remove('selected')); s.classList.add('selected'); });
    showModal('lineTypeModal');
  };
  document.getElementById('lineTypeCancel').onclick = () => hideModal('lineTypeModal');
  document.getElementById('lineTypeCreate').onclick = () => {
    const name = document.getElementById('lineTypeName').value.trim() || 'Line';
    const colorSel = document.querySelector('#lineTypeColorRow .color-swatch.selected');
    const color = colorSel ? colorSel.dataset.color : COLORS[2];
    state.lineTypes.push({ id: uid(), name, color });
    hideModal('lineTypeModal');
    updateUI();
  };

  document.getElementById('lineTypesSectionTitle').onclick = () => {
    document.getElementById('lineTypeSize').value = state.lineTypeSettings.lineSize ?? 2;
    document.getElementById('lineTypeSizeVal').textContent = state.lineTypeSettings.lineSize ?? 2;
    document.getElementById('lineTypeOpacity').value = Math.round((state.lineTypeSettings.opacity ?? 1) * 100);
    document.getElementById('lineTypeOpacityVal').textContent = Math.round((state.lineTypeSettings.opacity ?? 1) * 100);
    showModal('lineTypeSettingsModal');
  };
  document.getElementById('lineTypeSettingsClose').onclick = () => hideModal('lineTypeSettingsModal');
  document.getElementById('lineColorCancel').onclick = () => { state.pendingLineColorApply = null; hideModal('lineColorModal'); };
  document.getElementById('selectLineTypeCancel').onclick = () => hideModal('selectLineTypeModal');
  document.getElementById('lineColorCustom').onchange = () => applyLineColor(document.getElementById('lineColorCustom').value);
  document.getElementById('lineTypeSize').oninput = () => {
    state.lineTypeSettings.lineSize = parseInt(document.getElementById('lineTypeSize').value, 10);
    document.getElementById('lineTypeSizeVal').textContent = state.lineTypeSettings.lineSize;
    renderAnnotations();
  };
  document.getElementById('lineTypeOpacity').oninput = () => {
    state.lineTypeSettings.opacity = parseInt(document.getElementById('lineTypeOpacity').value, 10) / 100;
    document.getElementById('lineTypeOpacityVal').textContent = Math.round(state.lineTypeSettings.opacity * 100);
    renderAnnotations();
  };

  document.getElementById('pagesSectionTitle').onclick = () => {
    state.pagesListCollapsed = !state.pagesListCollapsed;
    document.getElementById('pagesSection').classList.toggle('collapsed', state.pagesListCollapsed);
    document.getElementById('pagesCollapseIcon').textContent = state.pagesListCollapsed ? '▶' : '▼';
  };
  document.getElementById('countersSectionTitle').onclick = () => {
    document.getElementById('counterSize').value = state.counterSettings.size;
    document.getElementById('counterSizeVal').textContent = state.counterSettings.size;
    document.getElementById('counterOpacity').value = Math.round(state.counterSettings.opacity * 100);
    document.getElementById('counterOpacityVal').textContent = Math.round(state.counterSettings.opacity * 100);
    document.getElementById('counterOutline').value = state.counterSettings.outlineSize != null ? state.counterSettings.outlineSize : 0;
    document.getElementById('counterOutlineVal').textContent = state.counterSettings.outlineSize != null ? state.counterSettings.outlineSize : 0;
    document.getElementById('counterShowRings').checked = state.counterSettings.showRings;
    document.getElementById('counterNumberSize').value = state.counterSettings.numberSize || 10;
    document.getElementById('counterNumberSizeVal').textContent = state.counterSettings.numberSize || 10;
    document.getElementById('counterRingSize').value = state.counterSettings.ringSize != null ? state.counterSettings.ringSize : 100;
    document.getElementById('counterRingSizeVal').textContent = state.counterSettings.ringSize != null ? state.counterSettings.ringSize : 100;
    document.getElementById('counterRingOpacity').value = Math.round((state.counterSettings.ringOpacity != null ? state.counterSettings.ringOpacity : 1) * 100);
    document.getElementById('counterRingOpacityVal').textContent = Math.round((state.counterSettings.ringOpacity != null ? state.counterSettings.ringOpacity : 1) * 100);
    document.getElementById('counterRingSolid').checked = !!state.counterSettings.ringSolid;
    showModal('counterSettingsModal');
  };
  document.getElementById('counterSettingsClose').onclick = () => hideModal('counterSettingsModal');
  document.getElementById('counterSize').oninput = () => {
    state.counterSettings.size = parseInt(document.getElementById('counterSize').value, 10);
    document.getElementById('counterSizeVal').textContent = state.counterSettings.size;
    renderAnnotations();
  };
  document.getElementById('counterOpacity').oninput = () => {
    state.counterSettings.opacity = parseInt(document.getElementById('counterOpacity').value, 10) / 100;
    document.getElementById('counterOpacityVal').textContent = Math.round(state.counterSettings.opacity * 100);
    renderAnnotations();
  };
  document.getElementById('counterOutline').oninput = () => {
    state.counterSettings.outlineSize = parseInt(document.getElementById('counterOutline').value, 10);
    document.getElementById('counterOutlineVal').textContent = state.counterSettings.outlineSize;
    renderAnnotations();
  };
  document.getElementById('counterShowRings').onchange = () => {
    state.counterSettings.showRings = document.getElementById('counterShowRings').checked;
    renderAnnotations();
  };
  document.getElementById('counterNumberSize').oninput = () => {
    state.counterSettings.numberSize = parseInt(document.getElementById('counterNumberSize').value, 10);
    document.getElementById('counterNumberSizeVal').textContent = state.counterSettings.numberSize;
    renderAnnotations();
  };
  document.getElementById('counterRingSize').oninput = () => {
    state.counterSettings.ringSize = parseInt(document.getElementById('counterRingSize').value, 10);
    document.getElementById('counterRingSizeVal').textContent = state.counterSettings.ringSize;
    renderAnnotations();
  };
  document.getElementById('counterRingOpacity').oninput = () => {
    state.counterSettings.ringOpacity = parseInt(document.getElementById('counterRingOpacity').value, 10) / 100;
    document.getElementById('counterRingOpacityVal').textContent = Math.round(state.counterSettings.ringOpacity * 100);
    renderAnnotations();
  };
  document.getElementById('counterRingSolid').onchange = () => {
    state.counterSettings.ringSolid = document.getElementById('counterRingSolid').checked;
    renderAnnotations();
  };

  document.getElementById('polylineCancel').onclick = () => hideModal('polylineModal');
  document.getElementById('polylineStart').onclick = () => {
    const lineTypeId = document.getElementById('polylineLineType').value || state.lineTypes[0]?.id;
    const name = document.getElementById('polylineName').value.trim() || 'Polyline';
    const colorSel = document.querySelector('#polylineColorRow .color-swatch.selected');
    const color = colorSel ? colorSel.dataset.color : COLORS[2];
    state.drawingPolyline = { id: uid(), name, color, points: [], closed: false, lineTypeId: lineTypeId || null };
    state.tool = TOOL.POLYLINE;
    hideModal('polylineModal');
    updateUI();
  };

  document.getElementById('finishPolyline').onclick = () => finishPolyline(false);
  document.getElementById('closePolygon').onclick = () => finishPolyline(true);

  function finishPolyline(closed) {
    if (!state.drawingPolyline || state.drawingPolyline.points.length < 2) return;
    if (closed && state.drawingPolyline.points.length >= 3) state.drawingPolyline.closed = true;
    const page = state.pages[state.currentPage];
    if (page && page.annotations) page.annotations.polylines.push(state.drawingPolyline);
    state.drawingPolyline = null;
    state.tool = TOOL.NONE;
    updateUI();
    renderPdf();
  }

  document.getElementById('zoomOut').onclick = () => { if (wheelZoomCommitTimer) { clearTimeout(wheelZoomCommitTimer); wheelZoomCommitTimer = null; } state.zoom = Math.max(0.2, state.zoom - 0.1); renderPdf(); updateUI(); };
  document.getElementById('zoomIn').onclick = () => { if (wheelZoomCommitTimer) { clearTimeout(wheelZoomCommitTimer); wheelZoomCommitTimer = null; } state.zoom = Math.min(8, state.zoom + 0.1); renderPdf(); updateUI(); };
  document.getElementById('zoomFit').onclick = () => { if (wheelZoomCommitTimer) { clearTimeout(wheelZoomCommitTimer); wheelZoomCommitTimer = null; } fitZoom(); };
  document.getElementById('prevPage').onclick = () => { if (state.currentPage > 0) { state.currentPage--; renderPdf(); updateUI(); } };
  document.getElementById('nextPage').onclick = () => { if (state.currentPage < state.pages.length - 1) { state.currentPage++; renderPdf(); updateUI(); } };

  document.getElementById('exportBtn').onclick = () => {
    const data = { version: 1, counters: state.counters, lineTypes: state.lineTypes, pages: state.pages.map((p, i) => ({ index: i, label: p.label, annotations: p.annotations, scale: p.scale })) };
    const a = document.createElement('a');
    a.href = 'data:application/json,' + encodeURIComponent(JSON.stringify(data));
    a.download = 'takeoff-project.json';
    a.click();
  };

  document.getElementById('exportPdf').onclick = () => {
    if (!state.pages.length) { alert('No pages loaded. Upload a PDF first.'); return; }
    const jsPDFLib = window.jspdf;
    if (!jsPDFLib || !jsPDFLib.jsPDF) { alert('Export PDF requires jsPDF. Please refresh the page.'); return; }
    document.getElementById('exportMarkerScale').value = Math.round((state.exportSettings.markerScale ?? 0.75) * 100);
    document.getElementById('exportMarkerScaleVal').textContent = document.getElementById('exportMarkerScale').value;
    document.getElementById('exportLineScale').value = Math.round((state.exportSettings.lineScale ?? 0.75) * 100);
    document.getElementById('exportLineScaleVal').textContent = document.getElementById('exportLineScale').value;
    showModal('exportPdfModal');
  };

  document.getElementById('exportMarkerScale').oninput = () => {
    document.getElementById('exportMarkerScaleVal').textContent = document.getElementById('exportMarkerScale').value;
  };
  document.getElementById('exportLineScale').oninput = () => {
    document.getElementById('exportLineScaleVal').textContent = document.getElementById('exportLineScale').value;
  };

  document.getElementById('exportPdfCancel').onclick = () => hideModal('exportPdfModal');

  document.getElementById('exportPdfDo').onclick = async () => {
    const markerScale = parseInt(document.getElementById('exportMarkerScale').value, 10) / 100;
    const lineScale = parseInt(document.getElementById('exportLineScale').value, 10) / 100;
    state.exportSettings.markerScale = markerScale;
    state.exportSettings.lineScale = lineScale;
    hideModal('exportPdfModal');
    const jsPDFLib = window.jspdf;
    const EXPORT_SCALE = 4;
    const PT_TO_MM = 25.4 / 72;
    const btn = document.getElementById('exportPdf');
    const origText = btn.textContent;
    const exportOverrides = { markerScale, lineScale };
    try {
      const firstViewport = state.pages[0].pdfPage.getViewport({ scale: EXPORT_SCALE });
      const firstW = (firstViewport.width / EXPORT_SCALE) * PT_TO_MM;
      const firstH = (firstViewport.height / EXPORT_SCALE) * PT_TO_MM;
      const doc = new jsPDFLib.jsPDF({ unit: 'mm', format: [firstW, firstH] });
      for (let i = 0; i < state.pages.length; i++) {
        btn.textContent = 'Exporting ' + (i + 1) + '/' + state.pages.length + '…';
        const page = state.pages[i];
        const viewport = page.pdfPage.getViewport({ scale: EXPORT_SCALE });
        const canvas = document.createElement('canvas');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const ctx = canvas.getContext('2d');
        await page.pdfPage.render({ canvasContext: ctx, viewport, intent: 'print' }).promise;
        renderAnnotationsToContext(ctx, page, EXPORT_SCALE, exportOverrides);
        const imgData = canvas.toDataURL('image/jpeg', 0.95);
        const wMm = (viewport.width / EXPORT_SCALE) * PT_TO_MM;
        const hMm = (viewport.height / EXPORT_SCALE) * PT_TO_MM;
        if (i > 0) doc.addPage([wMm, hMm], 'p');
        doc.addImage(imgData, 'JPEG', 0, 0, wMm, hMm);
      }
      doc.save('takeoff-with-marks.pdf');
    } catch (err) {
      console.error(err);
      alert('Export failed: ' + (err.message || err));
    }
    btn.textContent = origText;
  };

  document.getElementById('importBtn').onclick = () => document.getElementById('importInput').click();
  document.getElementById('importInput').onchange = (e) => {
    const f = e.target.files[0];
    if (!f) return;
    const r = new FileReader();
    r.onload = () => {
      try {
        const data = JSON.parse(r.result);
        if (data.counters) state.counters = data.counters;
        if (data.lineTypes) state.lineTypes = data.lineTypes;
        (data.pages || []).forEach(p => {
          const page = state.pages[p.index];
          if (page) {
            if (p.annotations) page.annotations = p.annotations;
            page.scale = p.scale !== undefined ? p.scale : (data.scale || null);
          }
        });
        updateUI();
        renderPdf();
      } catch (err) { alert('Invalid import file'); }
    };
    r.readAsText(f);
    e.target.value = '';
  };

  document.getElementById('clearPage').onclick = () => showModal('clearPageConfirmModal');
  document.getElementById('clearPageCancel').onclick = () => hideModal('clearPageConfirmModal');
  document.getElementById('clearPageConfirm').onclick = () => {
    hideModal('clearPageConfirmModal');
    const page = state.pages[state.currentPage];
    if (page) page.annotations = makeAnnotations();
    if (state.selectedLinePageIdx === state.currentPage) {
      state.selectedLineId = null;
      state.selectedLineIsPoly = false;
      state.selectedLinePageIdx = null;
    }
    renderPdf();
    updateUI();
  };

  document.getElementById('hamburger').onclick = () => document.body.classList.toggle('sidebar-open');
  document.getElementById('sidebarBackdrop').onclick = () => document.body.classList.remove('sidebar-open');

  document.getElementById('ctxDelete').onclick = () => {
    const t = state.ctxTarget;
    if (!t) return;
    const page = state.pages[state.currentPage];
    const ann = page?.annotations;
    if (!ann) return;
    if (t.type === 'marker') {
      const arr = ann.counterMarkers[t.typeId];
      if (arr) arr.splice(t.index, 1);
    } else if (t.type === 'quickLine') {
      const deletedId = ann.quickLines[t.index]?.id;
      ann.quickLines.splice(t.index, 1);
      if (deletedId === state.selectedLineId && !state.selectedLineIsPoly) {
        state.selectedLineId = null;
        state.selectedLineIsPoly = false;
        state.selectedLinePageIdx = null;
      }
    } else if (t.type === 'polyline') {
      const deletedId = ann.polylines[t.index]?.id;
      ann.polylines.splice(t.index, 1);
      if (deletedId === state.selectedLineId && state.selectedLineIsPoly) {
        state.selectedLineId = null;
        state.selectedLineIsPoly = false;
        state.selectedLinePageIdx = null;
      }
    }
    document.getElementById('contextMenu').classList.remove('visible');
    state.ctxTarget = null;
    renderPdf();
    updateUI();
  };

  function showContextMenu(x, y) {
    const menu = document.getElementById('contextMenu');
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';
    menu.classList.add('visible');
  }

  <!-- SECTION: Canvas Event Handlers -->
  function handleCanvasClick(e) {
    if (!state.pages.length) return;
    const pt = canvasPointFromEvent(e);
    const pdf = canvasToPdf(pt.x, pt.y);
    state.mousePos = pdf;
    if (state.tool === TOOL.SCALE) {
      if (state.scaleMode === SCALE_MODES.POINT_A) { state.scalePointA = pdf; state.scaleMode = SCALE_MODES.POINT_B; }
      else if (state.scaleMode === SCALE_MODES.POINT_B) {
        state.scalePointB = pdf;
        document.getElementById('scaleInfo').textContent = 'You selected a line spanning ' + Math.round(ptDist(state.scalePointA, state.scalePointB)) + ' pdf-pts.';
        document.getElementById('scaleValue').value = '';
        showModal('scaleModal');
      }
      renderPdf();
    } else if (state.tool === TOOL.LINE) {
      const lt = state.lineTypes.find(l => l.id === state.activeLineTypeId);
      if (!state.quickLineStart) state.quickLineStart = pdf;
      else {
        const page = state.pages[state.currentPage];
        if (page && page.annotations) page.annotations.quickLines.push({ x1: state.quickLineStart.x, y1: state.quickLineStart.y, x2: pdf.x, y2: pdf.y, color: lt?.color || '#4a9eff', id: uid(), lineTypeId: state.activeLineTypeId });
        state.quickLineStart = null;
      }
      renderPdf();
    } else if (state.tool === TOOL.POLYLINE && state.drawingPolyline) {
      state.drawingPolyline.points.push(pdf);
      renderAnnotations();
    } else if (state.tool === TOOL.COUNTER && state.activeCounterType) {
      const page = state.pages[state.currentPage];
      if (page && page.annotations) {
        if (!page.annotations.counterMarkers[state.activeCounterType]) page.annotations.counterMarkers[state.activeCounterType] = [];
        page.annotations.counterMarkers[state.activeCounterType].push({ x: pdf.x, y: pdf.y, id: uid() });
      }
      renderPdf();
    } else if (state.tool === TOOL.EDIT_POLY && state.editingPolyline) {
      const pts = state.editingPolyline.points || [];
      const r = 12 / state.zoom;
      const idx = pts.findIndex(p => ptDist(pdf, p) < r);
      if (state.draggingVertexIdx !== null) state.draggingVertexIdx = null;
    }
    updateUI();
  }

  function handleCanvasDblClick(e) {
    if (state.tool === TOOL.POLYLINE && state.drawingPolyline && state.drawingPolyline.points.length >= 2) finishPolyline(false);
  }

  function handleContextMenu(e) {
    e.preventDefault();
    const pt = canvasPointFromEvent(e);
    const pdf = canvasToPdf(pt.x, pt.y);
    if (state.tool === TOOL.EDIT_POLY && state.editingPolyline) {
      const pts = state.editingPolyline.points || [];
      const r = 12 / state.zoom;
      const idx = pts.findIndex(p => ptDist(pdf, p) < r);
      if (idx >= 0 && pts.length > 2) {
        pts.splice(idx, 1);
        renderAnnotations();
        updateUI();
        return;
      }
    }
    if (state.tool === TOOL.POLYLINE && state.drawingPolyline && state.drawingPolyline.points.length >= 3) {
      finishPolyline(true);
      return;
    }
    state.ctxTarget = hitTest(pdf);
    if (state.ctxTarget) showContextMenu(e.clientX, e.clientY);
  }

  <!-- SECTION: Event Binding -->
  const cWrapper = document.getElementById('canvasWrapper') || document.querySelector('.canvas-wrapper');
  let lastRenderedZoom = 1.0;
  let wheelZoomCommitTimer = null;
  function updateContainerTransform() {
    const scale = state.zoom / lastRenderedZoom;
    canvasContainer.style.transform = 'translate3d(' + state.pan.x + 'px, ' + state.pan.y + 'px, 0) scale(' + scale + ')';
  }
  function commitWheelZoom() {
    if (wheelZoomCommitTimer) clearTimeout(wheelZoomCommitTimer);
    wheelZoomCommitTimer = null;
    if (Math.abs(state.zoom - lastRenderedZoom) > 0.001) {
      lastRenderedZoom = state.zoom;
      renderPdf();
    }
    updateUI();
  }

  (cWrapper || pdfCanvas).addEventListener('mousedown', (e) => {
    if (!state.pages.length) return;
    if (e.button !== 0) return;
    const pt = canvasPointFromEvent(e);
    state.mousePos = canvasToPdf(pt.x, pt.y);
    if (state.tool === TOOL.NONE && !state.editingPolyline) {
      state.isPanning = true;
      state.panStart = { x: e.clientX - state.pan.x, y: e.clientY - state.pan.y };
    } else if (state.tool === TOOL.EDIT_POLY && state.editingPolyline) {
      const pts = state.editingPolyline.points || [];
      const pdfPt = canvasToPdf(pt.x, pt.y);
      const r = 12 / state.zoom;
      state.draggingVertexIdx = pts.findIndex(p => ptDist(pdfPt, p) < r);
    }
  });

  (cWrapper || pdfCanvas).addEventListener('mousemove', (e) => {
    const pt = canvasPointFromEvent(e);
    const pdf = canvasToPdf(pt.x, pt.y);
    state.mousePos = pdf;
    if (state.isPanning && state.panStart) {
      state.pan = { x: e.clientX - state.panStart.x, y: e.clientY - state.panStart.y };
      updateContainerTransform();
    } else if (state.tool === TOOL.EDIT_POLY && state.draggingVertexIdx !== null && state.editingPolyline) {
      state.editingPolyline.points[state.draggingVertexIdx] = pdf;
      renderAnnotations();
    } else if ((state.tool === TOOL.LINE && state.quickLineStart) || (state.tool === TOOL.POLYLINE && state.drawingPolyline && state.drawingPolyline.points.length >= 1)) {
      renderAnnotations();
    }
    updateStatus();
  });

  (cWrapper || pdfCanvas).addEventListener('mouseup', (e) => {
    if (e.button !== 0) return;
    state.isPanning = false;
    state.panStart = null;
    state.draggingVertexIdx = null;
  });

  (cWrapper || pdfCanvas).addEventListener('mouseleave', () => { state.isPanning = false; state.panStart = null; });

  (cWrapper || pdfCanvas).addEventListener('click', (e) => {
    if (state.isPanning) return;
    handleCanvasClick(e);
  });

  (cWrapper || pdfCanvas).addEventListener('dblclick', (e) => handleCanvasDblClick(e));
  (cWrapper || pdfCanvas).addEventListener('contextmenu', (e) => handleContextMenu(e));

  let wheelZoomPending = false;
  let wheelZoomAccum = 0;
  let wheelZoomCursor = null;
  (cWrapper || pdfCanvas).addEventListener('wheel', (e) => {
    e.preventDefault();
    let delta = -e.deltaY;
    if (e.deltaMode === 1) delta *= 24;
    else if (e.deltaMode === 2) delta *= 240;
    wheelZoomAccum += delta;
    wheelZoomCursor = canvasPointFromEvent(e);
    if (!wheelZoomPending) {
      wheelZoomPending = true;
      requestAnimationFrame(() => {
        wheelZoomPending = false;
        const delta = wheelZoomAccum;
        wheelZoomAccum = 0;
        if (delta === 0 || !wheelZoomCursor) return;
        const factor = 1 - delta * 0.001;
        const newZoom = Math.max(0.2, Math.min(8, state.zoom * factor));
        if (newZoom === state.zoom) return;
        const pt = wheelZoomCursor;
        const pdfX = (pt.x - state.pan.x) / state.zoom;
        const pdfY = (pt.y - state.pan.y) / state.zoom;
        state.pan.x = pt.x - pdfX * newZoom;
        state.pan.y = pt.y - pdfY * newZoom;
        state.zoom = newZoom;
        updateContainerTransform();
        updateUI();
        if (wheelZoomCommitTimer) clearTimeout(wheelZoomCommitTimer);
        wheelZoomCommitTimer = setTimeout(commitWheelZoom, 150);
      });
    }
  }, { passive: false });

  (cWrapper || pdfCanvas).addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      state.pinchStartDistance = ptDist({ x: e.touches[0].clientX, y: e.touches[0].clientY }, { x: e.touches[1].clientX, y: e.touches[1].clientY });
      state.pinchStartZoom = state.zoom;
    } else if (e.touches.length === 1) {
      state.longPressTimer = setTimeout(() => {
        state.longPressFired = true;
        const c = getClientCoords(e);
        const ev = new MouseEvent('contextmenu', { clientX: c.x, clientY: c.y, bubbles: true });
        (cWrapper || pdfCanvas).dispatchEvent(ev);
      }, 500);
      state.longPressStart = getClientCoords(e);
    }
  }, { passive: true });

  (cWrapper || pdfCanvas).addEventListener('touchmove', (e) => {
    if (e.touches.length === 2 && state.pinchStartDistance) {
      const d = ptDist({ x: e.touches[0].clientX, y: e.touches[0].clientY }, { x: e.touches[1].clientX, y: e.touches[1].clientY });
      const scale = d / state.pinchStartDistance;
      state.zoom = Math.max(0.2, Math.min(8, state.pinchStartZoom * scale));
      renderPdf();
      updateUI();
    } else if (e.touches.length === 1 && state.longPressTimer && state.longPressStart) {
      const c = getClientCoords(e);
      if (ptDist(state.longPressStart, c) > 10) { clearTimeout(state.longPressTimer); state.longPressTimer = null; }
    }
  }, { passive: true });

  (cWrapper || pdfCanvas).addEventListener('touchend', (e) => {
    if (e.touches.length < 2) state.pinchStartDistance = null;
    if (e.changedTouches && e.changedTouches.length && state.longPressTimer) {
      clearTimeout(state.longPressTimer);
      state.longPressTimer = null;
      if (!state.longPressFired) {
        const c = getClientCoords(e);
        const ev = new MouseEvent('click', { clientX: c.x, clientY: c.y, bubbles: true });
        (cWrapper || pdfCanvas).dispatchEvent(ev);
      }
      state.longPressFired = false;
    }
  }, { passive: true });

  document.addEventListener('click', (e) => {
    if (!e.target.closest('.context-menu') && !e.target.closest('#contextMenu')) document.getElementById('contextMenu').classList.remove('visible');
  });

  document.addEventListener('keydown', (e) => {
    if (e.target.matches('input, textarea, [contenteditable="true"]')) return;
    if (e.key === 'Escape') {
      if (document.getElementById('setScaleFirstModal').classList.contains('visible')) {
        hideModal('setScaleFirstModal');
        if (setScaleFirstToastTimer) { clearTimeout(setScaleFirstToastTimer); setScaleFirstToastTimer = null; }
      } else if (document.getElementById('setScaleFirstPolylineModal').classList.contains('visible')) {
        hideModal('setScaleFirstPolylineModal');
        if (setScaleFirstPolylineToastTimer) { clearTimeout(setScaleFirstPolylineToastTimer); setScaleFirstPolylineToastTimer = null; }
      } else if (document.getElementById('addLineTypeFirstModal').classList.contains('visible')) {
        hideModal('addLineTypeFirstModal');
        if (addLineTypeFirstToastTimer) { clearTimeout(addLineTypeFirstToastTimer); addLineTypeFirstToastTimer = null; }
      } else if (document.getElementById('selectLineTypeModal').classList.contains('visible')) {
        hideModal('selectLineTypeModal');
      } else if (document.getElementById('lineColorModal').classList.contains('visible')) { state.pendingLineColorApply = null; hideModal('lineColorModal'); }
      else if (document.getElementById('exportPdfModal').classList.contains('visible')) { hideModal('exportPdfModal'); }
      else if (document.getElementById('clearPageConfirmModal').classList.contains('visible')) { hideModal('clearPageConfirmModal'); }
      else if (state.tool === TOOL.EDIT_POLY) exitEditMode(false);
      else if (state.drawingPolyline) { state.drawingPolyline = null; state.tool = TOOL.NONE; updateUI(); }
      else if (state.tool === TOOL.LINE) {
        if (state.quickLineStart) { state.quickLineStart = null; renderPdf(); updateUI(); }
        else { state.tool = TOOL.NONE; updateUI(); }
      } else state.tool = TOOL.NONE;
    }
    if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') { if (state.currentPage > 0) { state.currentPage--; renderPdf(); updateUI(); } }
    if (e.key === 'ArrowRight' || e.key === 'ArrowDown') { if (state.currentPage < state.pages.length - 1) { state.currentPage++; renderPdf(); updateUI(); } }
    if (e.key === 'Enter' && state.drawingPolyline && state.drawingPolyline.points.length >= 2) finishPolyline(false);
    if (e.key === 'Enter' && state.tool === TOOL.EDIT_POLY) exitEditMode(true);
  });

  const stored = localStorage.getItem('takeoff-state');
  if (stored) {
    try {
      const data = JSON.parse(stored);
      if (data.counters) state.counters = data.counters || [];
      if (data.lineTypes) state.lineTypes = data.lineTypes || [];
      if (data.counterSettings) state.counterSettings = { ...state.counterSettings, ...data.counterSettings };
      if (data.lineTypeSettings) state.lineTypeSettings = { ...state.lineTypeSettings, ...data.lineTypeSettings };
      if (data.exportSettings) state.exportSettings = { ...state.exportSettings, ...data.exportSettings };
      if (data.recentLineColors) state.recentLineColors = data.recentLineColors;
      (data.pageAnnotations || []).forEach((ann, i) => {
        if (state.pages[i] && state.pages[i].annotations) state.pages[i].annotations = ann;
      });
      if (data.pageScales) {
        data.pageScales.forEach((scale, i) => { if (state.pages[i]) state.pages[i].scale = scale; });
      } else if (data.scale) {
        state.pages.forEach(p => { p.scale = data.scale; });
      }
    } catch (_) {}
  }

  setInterval(() => {
    if (state.pages.length || state.counters.length || state.lineTypes.length) localStorage.setItem('takeoff-state', JSON.stringify({ counters: state.counters, lineTypes: state.lineTypes, counterSettings: state.counterSettings, lineTypeSettings: state.lineTypeSettings, exportSettings: state.exportSettings, recentLineColors: state.recentLineColors, pageAnnotations: state.pages.map(p => p.annotations), pageScales: state.pages.map(p => p.scale) }));
  }, 5000);

  window.state = state;
  window.makeAnnotations = makeAnnotations;
  window.ptDist = ptDist;
  window.polylineDistance = polylineDistance;
  window.formatDist = formatDist;
  window.renderIconHtml = renderIconHtml;

  updateUI();
  })();
  </script>
  <script src="report.js"></script>
</body>
</html>
